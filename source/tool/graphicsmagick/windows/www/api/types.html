<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="en" name="language">
	<title>GraphicsMagick Types</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link media="screen" href="../docutils-articles.css" type="text/css" rel="stylesheet">

</head>

<body>

<div class="banner">
<img src="../images/gm-107x76.png" alt="GraphicMagick logo" width="107" height="76" />
<span class="title">GraphicsMagick</span>
<form action="http://www.google.com/search">
  <input type="hidden" name="domains" value="www.graphicsmagick.org" />
  <input type="hidden" name="sitesearch" value="www.graphicsmagick.org" />
<span class="nowrap"><input type="text" name="q" size="25" maxlength="255" />&nbsp;<input type="submit" name="sa" value="Search" /></span>
</form>
</div>


<div class="navmenu">
<ul>
  <li><a href="../index.html">Home</a></li>
  <li><a href="../project.html">Project</a></li>
  <li><a href="../download.html">Download</a></li>
  <li><a href="../README.html">Install</a></li>
  <li><a href="../Hg.html">Source</a></li>
  <li><a href="../NEWS.html">News</a> </li>
  <li><a href="../utilities.html">Utilities</a></li>
  <li><a href="../programming.html">Programming</a></li>
  <li><a href="../reference.html">Reference</a></li>
</ul>
</div>

<main id="graphicsmagick-types">
<h1 class="title">GraphicsMagick Types</h1>
<!-- -*- mode: rst -*- -->
<!-- This text is in reStucturedText format, so it may look a bit odd. -->
<!-- See http://docutils.sourceforge.net/rst.html for details. -->
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#affinematrix" id="id1">AffineMatrix</a></p></li>
<li><p><a class="reference internal" href="#blobinfo" id="id2">BlobInfo</a></p></li>
<li><p><a class="reference internal" href="#cache" id="id3">Cache</a></p></li>
<li><p><a class="reference internal" href="#channeltype" id="id4">ChannelType</a></p></li>
<li><p><a class="reference internal" href="#chromaticityinfo" id="id5">ChromaticityInfo</a></p></li>
<li><p><a class="reference internal" href="#classtype" id="id6">ClassType</a></p></li>
<li><p><a class="reference internal" href="#clippathunits" id="id7">ClipPathUnits</a></p></li>
<li><p><a class="reference internal" href="#colorpacket" id="id8">ColorPacket</a></p></li>
<li><p><a class="reference internal" href="#colorspacetype" id="id9">ColorspaceType</a></p></li>
<li><p><a class="reference internal" href="#compliancetype" id="id10">ComplianceType</a></p></li>
<li><p><a class="reference internal" href="#compositeoperator" id="id11">CompositeOperator</a></p></li>
<li><p><a class="reference internal" href="#compressiontype" id="id12">CompressionType</a></p></li>
<li><p><a class="reference internal" href="#decorationtype" id="id13">DecorationType</a></p></li>
<li><p><a class="reference internal" href="#drawcontext" id="id14">DrawContext</a></p></li>
<li><p><a class="reference internal" href="#drawinfo" id="id15">DrawInfo</a></p></li>
<li><p><a class="reference internal" href="#endiantype" id="id16">EndianType</a></p></li>
<li><p><a class="reference internal" href="#errorhandler" id="id17">ErrorHandler</a></p></li>
<li><p><a class="reference internal" href="#exceptioninfo" id="id18">ExceptionInfo</a></p></li>
<li><p><a class="reference internal" href="#exceptiontype" id="id19">ExceptionType</a></p></li>
<li><p><a class="reference internal" href="#fillrule" id="id20">FillRule</a></p></li>
<li><p><a class="reference internal" href="#filtertypes" id="id21">FilterTypes</a></p></li>
<li><p><a class="reference internal" href="#frameinfo" id="id22">FrameInfo</a></p></li>
<li><p><a class="reference internal" href="#gravitytype" id="id23">GravityType</a></p></li>
<li><p><a class="reference internal" href="#logeventtype" id="id24">LogEventType</a></p></li>
<li><p><a class="reference internal" href="#logmethod" id="id25">LogMethod</a></p></li>
<li><p><a class="reference internal" href="#logoutputtype" id="id26">LogOutputType</a></p></li>
<li><p><a class="reference internal" href="#image" id="id27">Image</a></p></li>
<li><p><a class="reference internal" href="#imageinfo" id="id28">ImageInfo</a></p></li>
<li><p><a class="reference internal" href="#imagetype" id="id29">ImageType</a></p></li>
<li><p><a class="reference internal" href="#indexpacket" id="id30">IndexPacket</a></p></li>
<li><p><a class="reference internal" href="#interlacetype" id="id31">InterlaceType</a></p></li>
<li><p><a class="reference internal" href="#layertype" id="id32">LayerType</a></p></li>
<li><p><a class="reference internal" href="#magickinfo" id="id33">MagickInfo</a></p></li>
<li><p><a class="reference internal" href="#monitorhandler" id="id34">MonitorHandler</a></p></li>
<li><p><a class="reference internal" href="#montageinfo" id="id35">MontageInfo</a></p></li>
<li><p><a class="reference internal" href="#noisetype" id="id36">NoiseType</a></p></li>
<li><p><a class="reference internal" href="#orientationtype" id="id37">OrientationType</a></p></li>
<li><p><a class="reference internal" href="#paintmethod" id="id38">PaintMethod</a></p></li>
<li><p><a class="reference internal" href="#pixelpacket" id="id39">PixelPacket</a></p></li>
<li><p><a class="reference internal" href="#pointinfo" id="id40">PointInfo</a></p></li>
<li><p><a class="reference internal" href="#profileinfo" id="id41">ProfileInfo</a></p></li>
<li><p><a class="reference internal" href="#quantizeinfo" id="id42">QuantizeInfo</a></p></li>
<li><p><a class="reference internal" href="#quantum" id="id43">Quantum</a></p></li>
<li><p><a class="reference internal" href="#quantumtype" id="id44">QuantumType</a></p></li>
<li><p><a class="reference internal" href="#rectangleinfo" id="id45">RectangleInfo</a></p></li>
<li><p><a class="reference internal" href="#registrytype" id="id46">RegistryType</a></p></li>
<li><p><a class="reference internal" href="#renderingintent" id="id47">RenderingIntent</a></p></li>
<li><p><a class="reference internal" href="#resolutiontype" id="id48">ResolutionType</a></p></li>
<li><p><a class="reference internal" href="#resourcetype" id="id49">ResourceType</a></p></li>
<li><p><a class="reference internal" href="#segmentinfo" id="id50">SegmentInfo</a></p></li>
<li><p><a class="reference internal" href="#signatureinfo" id="id51">SignatureInfo</a></p></li>
<li><p><a class="reference internal" href="#storagetype" id="id52">StorageType</a></p></li>
<li><p><a class="reference internal" href="#streamhandler" id="id53">StreamHandler</a></p></li>
<li><p><a class="reference internal" href="#stretchtype" id="id54">StretchType</a></p></li>
<li><p><a class="reference internal" href="#styletype" id="id55">StyleType</a></p></li>
<li><p><a class="reference internal" href="#typemetric" id="id56">TypeMetric</a></p></li>
<li><p><a class="reference internal" href="#viewinfo" id="id57">ViewInfo</a></p></li>
<li><p><a class="reference internal" href="#virtualpixelmethod" id="id58">VirtualPixelMethod</a></p></li>
<li><p><a class="reference internal" href="#magickxresourceinfo" id="id59">MagickXResourceInfo</a></p></li>
</ul>
</div>
<section id="affinematrix">
<h1><a class="toc-backref" href="#id1">AffineMatrix</a></h1>
<p>AffineMatrix defines a 2D affine matrix transform.</p>
<pre class="literal-block">typedef struct _AffineMatrix
{
  double
    sx,
    rx,
    ry,
    sy,
    tx,
    ty;
} AffineMatrix;</pre>
</section>
<section id="blobinfo">
<h1><a class="toc-backref" href="#id2">BlobInfo</a></h1>
<p>BlobInfo is an opaque pointer reference to the internal structure of an
I/O blob handle.</p>
</section>
<section id="cache">
<h1><a class="toc-backref" href="#id3">Cache</a></h1>
<pre class="literal-block">typedef void
  *Cache;</pre>
</section>
<section id="channeltype">
<h1><a class="toc-backref" href="#id4">ChannelType</a></h1>
<pre class="literal-block">typedef enum
{
  UndefinedChannel,
  RedChannel,     /* RGB Red channel */
  CyanChannel,    /* CMYK Cyan channel */
  GreenChannel,   /* RGB Green channel */
  MagentaChannel, /* CMYK Magenta channel */
  BlueChannel,    /* RGB Blue channel */
  YellowChannel,  /* CMYK Yellow channel */
  OpacityChannel, /* Opacity channel */
  BlackChannel,   /* CMYK Black (K) channel */
  MatteChannel,   /* Same as Opacity channel (deprecated) */
  AllChannels,    /* Color channels */
  GrayChannel     /* Color channels represent an intensity. */
} ChannelType;</pre>
</section>
<section id="chromaticityinfo">
<h1><a class="toc-backref" href="#id5">ChromaticityInfo</a></h1>
<p>The ChromaticityInfo structure is used to represent chromaticity
(colorspace primary coordinates in xy space) values for images in
GraphicsMagick.</p>
<p>The members of the ChromaticityInfo structure are shown in the following
table:</p>
<table>
<caption>ChromaticityInfo Structure Members</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 12%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr><td><p>Member</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>red_primary</p></td>
<td><p>PointInfo</p></td>
<td><p>Chromaticity red primary point (e.g. x=0.64, y=0.33)</p></td>
</tr>
<tr><td><p>green_primary</p></td>
<td><p>PointInfo</p></td>
<td><p>Chromaticity green primary point (e.g. x=0.3, y=0.6)</p></td>
</tr>
<tr><td><p>blue_primary</p></td>
<td><p>PointInfo</p></td>
<td><p>Chromaticity blue primary point (e.g. x=0.15, y=0.06)</p></td>
</tr>
<tr><td><p>white_point</p></td>
<td><p>PointInfo</p></td>
<td><p>Chromaticity white point (e.g. x=0.3127, y=0.329)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="classtype">
<h1><a class="toc-backref" href="#id6">ClassType</a></h1>
<p>The ClassType enumeration specifies the image storage class.  A
DirectClass representation of an image is based on an array of
PixelPacket structures in RAM and/or in a disk file where color values
are stored &quot;directly&quot;.  A PseudoClass representation of an image is
based on an array of IndexPacket values (also in RAM and/or in a disk
file) which are the index values to the Image colormap (a small array
of PixelPacket values) where the color values corresponding to the
pixel at the index are stored.</p>
<p>It is possible for an image to be represented as DirectClass and
PseudoClass simultaneously, but only one type may be claimed as the
current representation by the Image storage_class member.  It is
normally assumed that when the Image is set to PseudoClass that the
DirectClass representation is up to date but while updating the image,
this is often not the case.  The DirectClass representation of the
image may be updated based on the PseudoClass representation by
calling the SyncImage() function.</p>
<p>As a special case, CMYK is represented by the red, green, blue, and
opacity members of PixelPacket, and CMYKA is the same except that the
IndexPacket values represent Opacity.  CMYKA images are described as
DirectClass even though the IndexPacket values are used (the image
colormap is not valid).</p>
<table>
<caption>ClassType</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedClass</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>DirectClass</p></td>
<td><p>Image is composed of pixels which represent literal color values.</p></td>
</tr>
<tr><td><p>PseudoClass</p></td>
<td><p>Image is composed of pixels which specify an index in a color palette.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="clippathunits">
<h1><a class="toc-backref" href="#id7">ClipPathUnits</a></h1>
<pre class="literal-block">typedef enum
{
  UserSpace,
  UserSpaceOnUse,
  ObjectBoundingBox
} ClipPathUnits;</pre>
</section>
<section id="colorpacket">
<h1><a class="toc-backref" href="#id8">ColorPacket</a></h1>
<pre class="literal-block">typedef struct _ColorPacket
{
  PixelPacket
    pixel;

  unsigned short
    index;

  unsigned long
    count;
} ColorPacket;</pre>
</section>
<section id="colorspacetype">
<h1><a class="toc-backref" href="#id9">ColorspaceType</a></h1>
<p>The ColorspaceType enumeration is used to specify the colorspace that
quantization (color reduction and mapping) is done under or to specify
the colorspace when encoding an output image. Colorspaces are ways of
describing colors to fit the requirements of a particular application,
such as television, offset printing, and color monitors. Color reduction,
by default, takes place in the RGBColorspace. Empirical evidence suggests
that distances in color spaces such as YUVColorspace or YIQColorspace
correspond to perceptual color differences more closely than do distances
in RGB space. These color spaces may give better results when reducing the
color of an image. Refer to <a class="reference external" href="quantize.html">quantize</a> for more details.</p>
<p>When encoding an output image, the colorspaces RGBColorspace,
CMYKColorspace, and GRAYColorspace may be specified. The CMYKColorspace
option is only applicable when writing TIFF, JPEG, and Adobe Photoshop
bitmap (PSD) files.</p>
<table>
<caption>ColorspaceType</caption>
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr><th class="head"><p>Enumeration</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>UndefinedColorspace</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>RGBColorspace</p></td>
<td><p>Red, Green, Blue colorspace.</p></td>
</tr>
<tr><td><p>GRAYColorspace</p></td>
<td><p>Similar to Luma (Y) according to ITU-R 601</p></td>
</tr>
<tr><td><p>TransparentColorspace</p></td>
<td><p>RGB which preserves the matte while quantizing colors.</p></td>
</tr>
<tr><td><p>OHTAColorspace</p></td>
<td></td>
</tr>
<tr><td><p>XYZColorspace</p></td>
<td><p>CIE XYZ</p></td>
</tr>
<tr><td><p>YCCColorspace</p></td>
<td><p>Kodak PhotoCD PhotoYCC</p></td>
</tr>
<tr><td><p>YIQColorspace</p></td>
<td></td>
</tr>
<tr><td><p>YPbPrColorspace</p></td>
<td></td>
</tr>
<tr><td><p>YUVColorspace</p></td>
<td><p>YUV colorspace as used for computer video.</p></td>
</tr>
<tr><td><p>CMYKColorspace</p></td>
<td><p>Cyan, Magenta, Yellow, Black colorspace.</p></td>
</tr>
<tr><td><p>sRGBColorspace</p></td>
<td><p>Kodak PhotoCD sRGB</p></td>
</tr>
<tr><td><p>HSLColorspace</p></td>
<td><p>Hue, saturation, luminosity</p></td>
</tr>
<tr><td><p>HWBColorspace</p></td>
<td><p>Hue, whiteness, blackness</p></td>
</tr>
<tr><td><p>LABColorspace</p></td>
<td><p>ITU LAB</p></td>
</tr>
<tr><td><p>CineonLogRGBColorspace</p></td>
<td><p>RGB data with Cineon Log scaling, 2.048 density range</p></td>
</tr>
<tr><td><p>Rec601LumaColorspace</p></td>
<td><p>Luma (Y) according to ITU-R 601</p></td>
</tr>
<tr><td><p>Rec601YCbCrColorspace</p></td>
<td><p>YCbCr according to ITU-R 601</p></td>
</tr>
<tr><td><p>Rec709LumaColorspace</p></td>
<td><p>Luma (Y) according to ITU-R 709</p></td>
</tr>
<tr><td><p>Rec709YCbCrColorspace</p></td>
<td><p>YCbCr according to ITU-R 709</p></td>
</tr>
</tbody>
</table>
</section>
<section id="compliancetype">
<h1><a class="toc-backref" href="#id10">ComplianceType</a></h1>
<pre class="literal-block">typedef enum
{
  UndefinedCompliance = 0x0000,
  NoCompliance = 0x0000,
  SVGCompliance = 0x0001,
  X11Compliance = 0x0002,
  XPMCompliance = 0x0004,
  AllCompliance = 0xffff
} ComplianceType;</pre>
</section>
<section id="compositeoperator">
<h1><a class="toc-backref" href="#id11">CompositeOperator</a></h1>
<p>CompositeOperator is used to select the image composition algorithm used
to compose a composite image with an image. By default, each of the
composite image pixels are replaced by the corresponding image tile
pixel. Specify CompositeOperator to select a different algorithm.</p>
<p>The image compositor requires a matte, or alpha channel in the image for
some operations. This extra channel usually defines a mask which
represents a sort of cookie-cutter for the image. This is the case when
matte is 255 (full coverage) for pixels inside the shape, zero outside,
and between zero and 255 on the boundary. For certain operations, if
image does not have a matte channel, it is initialized with 0 for any
pixel matching in color to pixel location (0,0), otherwise 255 (to work
properly, borderWidth must be 0).</p>
<table>
<caption>CompositeOperator</caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr><th class="head"><p>Enumeration</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>UndefinedCompositeOp</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>OverCompositeOp</p></td>
<td><p>The result is the union of the the two image shapes with the composite
image obscuring image in the region of overlap.</p></td>
</tr>
<tr><td><p>InCompositeOp</p></td>
<td><p>The result is a simply composite image cut by the shape of image. None of
the image data of image is included in the result.</p></td>
</tr>
<tr><td><p>OutCompositeOp</p></td>
<td><p>The resulting image is composite image with the shape of image cut out.</p></td>
</tr>
<tr><td><p>AtopCompositeOp</p></td>
<td><p>The result is the same shape as image image, with composite image
obscuring image there the image shapes overlap. Note that this differs
from OverCompositeOp because the portion of composite image outside of
image's shape does not appear in the result.</p></td>
</tr>
<tr><td><p>XorCompositeOp</p></td>
<td><p>The result is the image data from both composite image and image that is
outside the overlap region. The overlap region will be blank.</p></td>
</tr>
<tr><td><p>PlusCompositeOp</p></td>
<td><p>The result is just the sum of the  image data. Output values are cropped
to 255 (no overflow). This operation is independent of the matte channels.</p></td>
</tr>
<tr><td><p>MinusCompositeOp</p></td>
<td><p>The result of composite image - image, with overflow cropped to zero. The
matte chanel is ignored (set to 255, full coverage).</p></td>
</tr>
<tr><td><p>AddCompositeOp</p></td>
<td><p>The result of composite image + image, with overflow wrapping around (mod
256).</p></td>
</tr>
<tr><td><p>SubtractCompositeOp</p></td>
<td><p>The result of composite image - image, with underflow wrapping around (mod
256). The add and subtract operators can be used to perform reversible
transformations.</p></td>
</tr>
<tr><td><p>DifferenceCompositeOp</p></td>
<td><p>The result of abs(composite image - image). This is useful for comparing
two very similar images.</p></td>
</tr>
<tr><td><p>MultiplyCompositeOp</p></td>
<td><p>The result of composite image × image. This is useful for the creation of
drop-shadows.</p></td>
</tr>
<tr><td><p>BumpmapCompositeOp</p></td>
<td><p>The result image shaded by composite image.</p></td>
</tr>
<tr><td><p>CopyCompositeOp</p></td>
<td><p>The resulting image is image replaced with composite image. Here the matte
information is ignored.</p></td>
</tr>
<tr><td><p>CopyRedCompositeOp</p></td>
<td><p>The resulting image is the red layer in image replaced with the red layer
in composite image. The other layers are copied untouched.</p></td>
</tr>
<tr><td><p>CopyGreenCompositeOp</p></td>
<td><p>The resulting image is the green layer in image replaced with the green
layer in composite image. The other layers are copied untouched.</p></td>
</tr>
<tr><td><p>CopyBlueCompositeOp</p></td>
<td><p>The resulting image is the blue layer in image replaced with the blue
layer in composite image. The other layers are copied untouched.</p></td>
</tr>
<tr><td><p>CopyOpacityCompositeOp</p></td>
<td><p>The resulting image is the matte layer in image replaced with the matte
layer in composite image. The other layers are copied untouched.</p></td>
</tr>
<tr><td><p>ClearCompositeOp</p></td>
<td><p>Pixels in the region are set to Transparent.</p></td>
</tr>
<tr><td><p>DissolveCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>DisplaceCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>ModulateCompositeOp</p></td>
<td><p>Modulate brightness in HSL space.</p></td>
</tr>
<tr><td><p>ThresholdCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>NoCompositeOp</p></td>
<td><p>Do nothing at all.</p></td>
</tr>
<tr><td><p>DarkenCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>LightenCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>HueCompositeOp</p></td>
<td><p>Copy Hue channel (from HSL colorspace).</p></td>
</tr>
<tr><td><p>SaturateCompositeOp</p></td>
<td><p>Copy Saturation channel (from HSL colorspace).</p></td>
</tr>
<tr><td><p>ColorizeCompositeOp</p></td>
<td><p>Copy Hue and Saturation channels (from HSL colorspace).</p></td>
</tr>
<tr><td><p>LuminizeCompositeOp</p></td>
<td><p>Copy Brightness channel (from HSL colorspace).</p></td>
</tr>
<tr><td><p>ScreenCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>OverlayCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>CopyCyanCompositeOp</p></td>
<td><p>Copy the Cyan channel.</p></td>
</tr>
<tr><td><p>CopyMagentaCompositeOp</p></td>
<td><p>Copy the Magenta channel.</p></td>
</tr>
<tr><td><p>CopyYellowCompositeOp</p></td>
<td><p>Copy the Yellow channel.</p></td>
</tr>
<tr><td><p>CopyBlackCompositeOp</p></td>
<td><p>Copy the Black channel.</p></td>
</tr>
<tr><td><p>DivideCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>HardLightCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>ExclusionCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>ColorDodgeCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>ColorBurnCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>SoftLightCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>LinearBurnCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>LinearDodgeCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>LinearLightCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>VividLightCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>PinLightCompositeOp</p></td>
<td></td>
</tr>
<tr><td><p>HardMixCompositeOp</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="compressiontype">
<h1><a class="toc-backref" href="#id12">CompressionType</a></h1>
<p>CompressionType is used to specify the desired compression type when
encoding an image. Be aware that most image types only support a subset
of the available compression types. If the specified compression type is
incompatible with the image, GraphicsMagick will select a compression type
compatible with the image type, which might be no compression at all.</p>
<table>
<caption>CompressionType</caption>
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedCompression</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>NoCompression</p></td>
<td><p>No compression</p></td>
</tr>
<tr><td><p>BZipCompression</p></td>
<td><p>BZip (Burrows-Wheeler block-sorting text compression algorithm and
Huffman coding)  as used by bzip2 utilities</p></td>
</tr>
<tr><td><p>FaxCompression</p></td>
<td><p>CCITT Group 3 FAX compression</p></td>
</tr>
<tr><td><p>Group4Compression</p></td>
<td><p>CCITT Group 4 FAX compression (used only for TIFF)</p></td>
</tr>
<tr><td><p>JPEGCompression</p></td>
<td><p>JPEG compression</p></td>
</tr>
<tr><td><p>LosslessJPEGCompression</p></td>
<td><p>Lossless JPEG compression</p></td>
</tr>
<tr><td><p>LZWCompression</p></td>
<td><p>Lempel-Ziv-Welch (LZW) compression (caution, patented by Unisys)</p></td>
</tr>
<tr><td><p>RLECompression</p></td>
<td><p>Run-Length encoded (RLE) compression</p></td>
</tr>
<tr><td><p>ZipCompression</p></td>
<td><p>Lempel-Ziv compression (LZ77) as used in PKZIP and GNU gzip.</p></td>
</tr>
<tr><td><p>LZMACompression</p></td>
<td><p>LZMA - Lempel-Ziv-Markov chain algorithm</p></td>
</tr>
<tr><td><p>JPEG2000Compression</p></td>
<td><p>JPEG 2000 - ISO/IEC std 15444-1</p></td>
</tr>
<tr><td><p>JBIG1Compression</p></td>
<td><p>JBIG v1 - ISO/IEC std 11544 / ITU-T rec T.82</p></td>
</tr>
<tr><td><p>JBIG2Compression</p></td>
<td><p>JBIG v2 - ISO/IEC std 14492 / ITU-T rec T.88</p></td>
</tr>
<tr><td><p>ZSTDCompression</p></td>
<td><p>Facebook's Zstandard/Zstd</p></td>
</tr>
<tr><td><p>WebPCompression</p></td>
<td><p>Google's WebP</p></td>
</tr>
</tbody>
</table>
</section>
<section id="decorationtype">
<h1><a class="toc-backref" href="#id13">DecorationType</a></h1>
<pre class="literal-block">typedef enum
{
  NoDecoration,
  UnderlineDecoration,
  OverlineDecoration,
  LineThroughDecoration
} DecorationType;</pre>
</section>
<section id="drawcontext">
<h1><a class="toc-backref" href="#id14">DrawContext</a></h1>
<pre class="literal-block">typedef struct _DrawContext *DrawContext;</pre>
</section>
<section id="drawinfo">
<h1><a class="toc-backref" href="#id15">DrawInfo</a></h1>
<p>The DrawInfo structure is used to support annotating an image using
drawing commands.</p>
<table>
<caption>Methods Supporting DrawInfo</caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<tbody>
<tr><td><p>Method</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>GetDrawInfo()</p></td>
<td><p>Allocate new structure with defaults set.</p></td>
</tr>
<tr><td><p>CloneDrawInfo()</p></td>
<td><p>Copy existing structure, allocating new structure in the process.</p></td>
</tr>
<tr><td><p>DestroyDrawInfo()</p></td>
<td><p>Deallocate structure, including any members.</p></td>
</tr>
<tr><td><p>DrawImage()</p></td>
<td><p>Render primitives to image.</p></td>
</tr>
</tbody>
</table>
<p>The members of the DrawInfo structure are shown in the following table.
The structure is initialized to reasonable defaults by first initializing
the equivalent members of ImageInfo, and then initializing the entire
structure using GetDrawInfo().</p>
<table>
<caption>DrawInfo Structure Members Supporting DrawImage()</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 14%" />
<col style="width: 69%" />
</colgroup>
<tbody>
<tr><td><p>Member</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>affine</p></td>
<td><p>AffineInfo</p></td>
<td><p>Coordinate transformation (rotation, scaling, and translation).</p></td>
</tr>
<tr><td><p>border_color</p></td>
<td><p>PixelPacket</p></td>
<td><p>Border color</p></td>
</tr>
<tr><td><p>decorate</p></td>
<td><p>DecorationType</p></td>
<td><p>Text decoration type.</p></td>
</tr>
<tr><td><p>density</p></td>
<td><p>char *</p></td>
<td><p>Text rendering density in DPI (effects scaling font according to
pointsize). E.g. &quot;72x72&quot;</p></td>
</tr>
<tr><td><p>fill</p></td>
<td><p>PixelPacket</p></td>
<td><p>Object internal fill (within outline) color.</p></td>
</tr>
<tr><td><p>font</p></td>
<td><p>char *</p></td>
<td><p>Font to use when rendering text.</p></td>
</tr>
<tr><td><p>gravity</p></td>
<td><p>GravityType</p></td>
<td><p>Text placement preference (e.g. NorthWestGravity).</p></td>
</tr>
<tr><td><p>linewidth</p></td>
<td><p>double</p></td>
<td><p>Stroke (outline) drawing width in pixels.</p></td>
</tr>
<tr><td><p>pointsize</p></td>
<td><p>double</p></td>
<td><p>Font size (also see density).</p></td>
</tr>
<tr><td><p>primitive</p></td>
<td><p>char *</p></td>
<td><p>Space or new-line delimited list of text drawing primitives (e.g
&quot;text 100,100 Cockatoo&quot;). See the table Drawing Primitives for the
available drawing primitives.</p></td>
</tr>
<tr><td><p>stroke</p></td>
<td><p>PixelPacket</p></td>
<td><p>Object stroke (outline) color.</p></td>
</tr>
<tr><td><p>stroke_antialias</p></td>
<td><p>unsigned int</p></td>
<td><p>Set to True (non-zero) to obtain anti-aliased stroke rendering.</p></td>
</tr>
<tr><td><p>text_antialias</p></td>
<td><p>unsigned int</p></td>
<td><p>Set to True (non-zero) to obtain anti-aliased text rendering.</p></td>
</tr>
<tr><td><p>tile</p></td>
<td><p>Image *</p></td>
<td><p>Image texture to draw with. Use an image containing a single color
(e.g. a 1x1 image) to draw in a solid color.</p></td>
</tr>
</tbody>
</table>
<p>Drawing Primitives</p>
<p>The drawing primitives shown in the following table may be supplied as a
space or new-line delimited list to the primitive member. Primitives
which set drawing options effect the results from subsequent drawing
operations. See the 'push graphic-context' and 'pop graphic-context'
primitives for a way to control the propagation of drawing options.</p>
<table>
<caption>Drawing Primitives</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 28%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr><td><p>Primitive</p></td>
<td><p>Arguments</p></td>
<td><p>Purpose</p></td>
</tr>
<tr><td><p>affine</p></td>
<td><p>sx,rx,ry,sy,tx,ty</p></td>
<td><p>Apply coordinate transformations to support scaling
(s), rotation (r), and translation (t). Angles are
specified in radians. Equivalent to SVG matrix command
which supplies a transformation matrix.</p></td>
</tr>
<tr><td><p>angle</p></td>
<td><p>angle</p></td>
<td><p>Specify object drawing angle.</p></td>
</tr>
<tr><td><p>arc</p></td>
<td><p>startX,startY endX,endY
startDegrees,endDegrees</p></td>
<td><p>Draw an arc.</p></td>
</tr>
<tr><td><p>Bezier</p></td>
<td><p>x1,y1, x2,y2, x3,y3, ...,
xN,yN</p></td>
<td><p>Draw a Bezier curve.</p></td>
</tr>
<tr><td><p>circle</p></td>
<td><p>originX,originY
perimX,perimY</p></td>
<td><p>Draw a circle.</p></td>
</tr>
<tr><td><p>color</p></td>
<td><p>x,y (point|replace|
floodfill|filltoborder|
reset)</p></td>
<td><p>Set color in image according to specified colorization
rule.</p></td>
</tr>
<tr><td><p>decorate</p></td>
<td><p>(none|underline|overline|
line-through)</p></td>
<td><p>Specify text decoration.</p></td>
</tr>
<tr><td><p>ellipse</p></td>
<td><p>originX,originY
width,height
arcStart,arcEnd</p></td>
<td><p>Draw an ellipse.</p></td>
</tr>
<tr><td><p>fill</p></td>
<td><p>colorspec</p></td>
<td><p>Specifiy object filling color.</p></td>
</tr>
<tr><td><p>fill-opacity</p></td>
<td><p>opacity</p></td>
<td><p>Specify object fill opacity.</p></td>
</tr>
<tr><td><p>font</p></td>
<td><p>fontname</p></td>
<td><p>Specify text drawing font.</p></td>
</tr>
<tr><td><p>gravity</p></td>
<td><p>(NorthWest,North,NorthEast,
West,Center,East,
SouthWest,South,SouthEast)</p></td>
<td><p>Specify text positioning gravity.</p></td>
</tr>
<tr><td><p>image</p></td>
<td><p>x,y width,height filename</p></td>
<td><p>Composite image at position, scaled to specified width
and height, and specified filename. If width or height
is zero, scaling is not performed.</p></td>
</tr>
<tr><td><p>line</p></td>
<td><p>startX,startY endX,endY</p></td>
<td><p>Draw a line.</p></td>
</tr>
<tr><td><p>matte</p></td>
<td><p>x,y (point|replace|
floodfill|filltoborder|
reset)</p></td>
<td><p>Set matte in image according to specified colorization
rule.</p></td>
</tr>
<tr><td><p>opacity</p></td>
<td><p>fillOpacity strokeOpacity</p></td>
<td><p>Specify drawing fill and stroke opacities.</p></td>
</tr>
<tr><td><p>path</p></td>
<td><p>'SVG-compatible path
arguments'</p></td>
<td><p>Draw using SVG-compatible path drawing commands.</p></td>
</tr>
<tr><td><p>point</p></td>
<td><p>x,y</p></td>
<td><p>Set point to fill color.</p></td>
</tr>
<tr><td><p>pointsize</p></td>
<td><p>pointsize</p></td>
<td><p>Specify text drawing pointsize (scaled to density).</p></td>
</tr>
<tr><td><p>polygon</p></td>
<td><p>x1,y1, x2,y2, x3,y3, ...,
xN,yN</p></td>
<td><p>Draw a polygon.</p></td>
</tr>
<tr><td><p>polyline</p></td>
<td><p>x1,y1, x2,y2, x3,y3, ...,
xN,yN</p></td>
<td><p>Draw a polyline.</p></td>
</tr>
<tr><td><p>pop</p></td>
<td><p>graphic-context</p></td>
<td><p>Remove options set since previous &quot;push
graphic-context&quot; command. Options revert to those in
effect prior to pushing the graphic context.</p></td>
</tr>
<tr><td><p>push</p></td>
<td><p>graphic-context</p></td>
<td><p>Specify new graphic context.</p></td>
</tr>
<tr><td><p>rect</p></td>
<td><p>upperLeftX,upperLeftY
lowerRightX,lowerRightY</p></td>
<td><p>Draw a rectangle.</p></td>
</tr>
<tr><td><p>rotate</p></td>
<td><p>angle</p></td>
<td><p>Specify coordiante space rotation. Subsequent objects
are drawn with coordate space rotated by specified
angle.</p></td>
</tr>
<tr><td><p>roundrectangle</p></td>
<td><p>centerX,centerY
width,hight
cornerWidth,cornerHeight</p></td>
<td><p>Draw a rectangle with rounded corners.</p></td>
</tr>
<tr><td><p>stroke</p></td>
<td><p>colorspec</p></td>
<td><p>Specify object stroke (outline) color.</p></td>
</tr>
<tr><td><p>stroke-antialias</p></td>
<td><p>stroke_antialias (0 or 1)</p></td>
<td><p>Specify if stroke should be antialiased or not.</p></td>
</tr>
<tr><td><p>stroke-dash</p></td>
<td><p>value</p></td>
<td><p>Specify pattern to be used when drawing stroke.</p></td>
</tr>
<tr><td><p>stroke-opacity</p></td>
<td><p>opacity</p></td>
<td><p>Specify opacity of stroke drawing color.</p></td>
</tr>
<tr><td><p>stroke-width</p></td>
<td><p>linewidth</p></td>
<td><p>Specify stroke (outline) width in pixels.</p></td>
</tr>
<tr><td><p>text</p></td>
<td><p>x,y &quot;some text&quot;</p></td>
<td><p>Draw text at position.</p></td>
</tr>
<tr><td><p>text-antialias</p></td>
<td><p>text_antialias (0 or 1)</p></td>
<td><p>Specify if rendered text is to be antialiased (blend
edges).</p></td>
</tr>
<tr><td><p>scale</p></td>
<td><p>x,y</p></td>
<td><p>Specify scaling to be applied to coordintate space for
subsequent drawing commands.</p></td>
</tr>
<tr><td><p>translate</p></td>
<td><p>x,y</p></td>
<td><p>Specify center of coordinate space to use for
subsequent drawing commands.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="endiantype">
<h1><a class="toc-backref" href="#id16">EndianType</a></h1>
<p>Some formats, such as TIFF and DPX, allow storing data in multiple
&quot;endian&quot; orders and EndianType allows controlling that. With MSB
endian and accessing memory bytes with increasing offset, the most
significant byte is encountered first, while with LSB endian, the
least significant byte is encountered first.</p>
<pre class="literal-block">typedef enum
{
  UndefinedEndian,
  LSBEndian,            /* &quot;little&quot; endian */
  MSBEndian,            /* &quot;big&quot; endian */
  NativeEndian          /* native endian */
} EndianType;</pre>
</section>
<section id="errorhandler">
<h1><a class="toc-backref" href="#id17">ErrorHandler</a></h1>
<pre class="literal-block">typedef void
  (*ErrorHandler)(const ExceptionType,const char *,const char *);</pre>
</section>
<section id="exceptioninfo">
<h1><a class="toc-backref" href="#id18">ExceptionInfo</a></h1>
<pre class="literal-block">typedef struct _ExceptionInfo
{
  char
    *reason,
    *description;

  ExceptionType
    severity;

  unsigned long
    signature;
} ExceptionInfo;</pre>
</section>
<section id="exceptiontype">
<h1><a class="toc-backref" href="#id19">ExceptionType</a></h1>
<p>Warnings and errors are represented by integer numbers (declared as an
ExceptionType enumeration) with the range of warnings starting with
WarningException, the range of errors starting with ErrorException,
and the range of fatal errors starting with FatalErrorException.</p>
<pre class="literal-block">typedef enum
{
  UndefinedException,
  WarningException = 300,
  ResourceLimitWarning = 300,
  TypeWarning = 305,
  OptionWarning = 310,
  DelegateWarning = 315,
  MissingDelegateWarning = 320,
  CorruptImageWarning = 325,
  FileOpenWarning = 330,
  BlobWarning = 335,
  StreamWarning = 340,
  CacheWarning = 345,
  CoderWarning = 350,
  ModuleWarning = 355,
  DrawWarning = 360,
  ImageWarning = 365,
  XServerWarning = 380,
  MonitorWarning = 385,
  RegistryWarning = 390,
  ConfigureWarning = 395,
  ErrorException = 400,
  ResourceLimitError = 400,
  TypeError = 405,
  OptionError = 410,
  DelegateError = 415,
  MissingDelegateError = 420,
  CorruptImageError = 425,
  FileOpenError = 430,
  BlobError = 435,
  StreamError = 440,
  CacheError = 445,
  CoderError = 450,
  ModuleError = 455,
  DrawError = 460,
  ImageError = 465,
  XServerError = 480,
  MonitorError = 485,
  RegistryError = 490,
  ConfigureError = 495,
  FatalErrorException = 700,
  ResourceLimitFatalError = 700,
  TypeFatalError = 705,
  OptionFatalError = 710,
  DelegateFatalError = 715,
  MissingDelegateFatalError = 720,
  CorruptImageFatalError = 725,
  FileOpenFatalError = 730,
  BlobFatalError = 735,
  StreamFatalError = 740,
  CacheFatalError = 745,
  CoderFatalError = 750,
  ModuleFatalError = 755,
  DrawFatalError = 760,
  ImageFatalError = 765,
  XServerFatalError = 780,
  MonitorFatalError = 785,
  RegistryFatalError = 790,
  ConfigureFatalError = 795
} ExceptionType;</pre>
</section>
<section id="fillrule">
<h1><a class="toc-backref" href="#id20">FillRule</a></h1>
<pre class="literal-block">typedef enum
{
  UndefinedRule,
  EvenOddRule,
  NonZeroRule
} FillRule;</pre>
</section>
<section id="filtertypes">
<h1><a class="toc-backref" href="#id21">FilterTypes</a></h1>
<p>FilterTypes is used to adjust the filter algorithm used when resizing
images. Different filters experience varying degrees of success with
various images and can take significantly different amounts of processing
time. GraphicsMagick defaults to using the LanczosFilter, which has been
proven to provide the best results for most images in a reasonable amount
of time. Other filter types, such as the TriangleFilter, may execute much faster
but may show artifacts when the image is resized or around diagonal lines.
The only way to be sure is to test the filter with sample images.</p>
<table>
<caption>FilterTypes</caption>
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedFilter</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>PointFilter</p></td>
<td><p>Point Filter</p></td>
</tr>
<tr><td><p>BoxFilter</p></td>
<td><p>Box Filter</p></td>
</tr>
<tr><td><p>TriangleFilter</p></td>
<td><p>Triangle Filter</p></td>
</tr>
<tr><td><p>HermiteFilter</p></td>
<td><p>Hermite Filter</p></td>
</tr>
<tr><td><p>HanningFilter</p></td>
<td><p>Hanning Filter</p></td>
</tr>
<tr><td><p>HammingFilter</p></td>
<td><p>Hamming Filter</p></td>
</tr>
<tr><td><p>BlackmanFilter</p></td>
<td><p>Blackman Filter</p></td>
</tr>
<tr><td><p>GaussianFilter</p></td>
<td><p>Gaussian Filter</p></td>
</tr>
<tr><td><p>QuadraticFilter</p></td>
<td><p>Quadratic Filter</p></td>
</tr>
<tr><td><p>CubicFilter</p></td>
<td><p>Cubic Filter</p></td>
</tr>
<tr><td><p>CatromFilter</p></td>
<td><p>Catrom Filter</p></td>
</tr>
<tr><td><p>MitchellFilter</p></td>
<td><p>Mitchell Filter</p></td>
</tr>
<tr><td><p>LanczosFilter</p></td>
<td><p>Lanczos Filter</p></td>
</tr>
<tr><td><p>BesselFilter</p></td>
<td><p>Bessel Filter</p></td>
</tr>
<tr><td><p>SincFilter</p></td>
<td><p>Sinc Filter</p></td>
</tr>
</tbody>
</table>
</section>
<section id="frameinfo">
<h1><a class="toc-backref" href="#id22">FrameInfo</a></h1>
<pre class="literal-block">typedef struct _FrameInfo
{
  unsigned long
    width,
    height;

  long
    x,
    y,
    inner_bevel,
    outer_bevel;
} FrameInfo;</pre>
</section>
<section id="gravitytype">
<h1><a class="toc-backref" href="#id23">GravityType</a></h1>
<p>GravityType specifies positioning of an object, such as text or an image,
within a bounding region. Gravity provides a convenient way to
locate objects irrespective of the size of the bounding region, in other
words, you don't need to provide absolute coordinates in order to
position an object. A common default for gravity is NorthWestGravity.</p>
<table>
<caption>GravityType</caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>ForgetGravity</p></td>
<td><p>Don't use gravity.</p></td>
</tr>
<tr><td><p>NorthWestGravity</p></td>
<td><p>Position object at top-left of region.</p></td>
</tr>
<tr><td><p>NorthGravity</p></td>
<td><p>Postiion object at top-center of region</p></td>
</tr>
<tr><td><p>NorthEastGravity</p></td>
<td><p>Position object at top-right of region</p></td>
</tr>
<tr><td><p>WestGravity</p></td>
<td><p>Position object at left-center of region</p></td>
</tr>
<tr><td><p>CenterGravity</p></td>
<td><p>Position object at center of region</p></td>
</tr>
<tr><td><p>EastGravity</p></td>
<td><p>Position object at right-center of region</p></td>
</tr>
<tr><td><p>SouthWestGravity</p></td>
<td><p>Position object at left-bottom of region</p></td>
</tr>
<tr><td><p>SouthGravity</p></td>
<td><p>Position object at bottom-center of region</p></td>
</tr>
<tr><td><p>SouthEastGravity</p></td>
<td><p>Position object at bottom-right of region</p></td>
</tr>
</tbody>
</table>
</section>
<section id="logeventtype">
<h1><a class="toc-backref" href="#id24">LogEventType</a></h1>
<p>LogEventType specifies the log event type to match one or more log
areas.  Although defined as an enum type, the values are based on
unsigned integer flags value with one mask bit set, more than one mask
bit set, or all of the assigned mask bits set.  Values are boolean
ORed together to represent multiple event types.</p>
<table>
<caption>LogEventType</caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedEventMask</p></td>
<td><p>No events specified</p></td>
</tr>
<tr><td><p>NoEventsMask</p></td>
<td><p>No events specified</p></td>
</tr>
<tr><td><p>ConfigureEventMask</p></td>
<td><p>Configuration event (related to initialization or shutdown)</p></td>
</tr>
<tr><td><p>AnnotateEventMask</p></td>
<td><p>Annotation event (text drawing)</p></td>
</tr>
<tr><td><p>RenderEventMask</p></td>
<td><p>Rendering event (vector drawing)</p></td>
</tr>
<tr><td><p>TransformEventMask</p></td>
<td><p>Image transformation event (e.g. cropping)</p></td>
</tr>
<tr><td><p>LocaleEventMask</p></td>
<td><p>Locale event (internationalization)</p></td>
</tr>
<tr><td><p>CoderEventMask</p></td>
<td><p>Coder event (file decode or encode)</p></td>
</tr>
<tr><td><p>X11EventMask</p></td>
<td><p>X11 event (event related to use of X11)</p></td>
</tr>
<tr><td><p>CacheEventMask</p></td>
<td><p>Pixel cache event (pixel storage in memory or on disk)</p></td>
</tr>
<tr><td><p>BlobEventMask</p></td>
<td><p>Blob event (I/O to/from memory or a file)</p></td>
</tr>
<tr><td><p>DeprecateEventMask</p></td>
<td><p>Deprecation event (use of a function which will be removed)</p></td>
</tr>
<tr><td><p>UserEventMask</p></td>
<td><p>User event (event allowed for the user, not otherwise used)</p></td>
</tr>
<tr><td><p>ResourceEventMask</p></td>
<td><p>Resource event (resource limit assignment, allocation/deallocation)</p></td>
</tr>
<tr><td><p>TemporaryFileEventMask</p></td>
<td><p>Temporary file event (temporary file created or removed)</p></td>
</tr>
<tr><td><p>ExceptionEventMask</p></td>
<td><p>Exception event (a warning or error was reported into ExceptionInfo)</p></td>
</tr>
<tr><td><p>OptionEventMask</p></td>
<td><p>Option event (something related to a user provided option)</p></td>
</tr>
<tr><td><p>InformationEventMask</p></td>
<td><p>Information event</p></td>
</tr>
<tr><td><p>WarningEventMask</p></td>
<td><p>Warning event (a warning was reported into ExceptionInfo)</p></td>
</tr>
<tr><td><p>ErrorEventMask</p></td>
<td><p>Error event (an error was reported into ExceptionInfo)</p></td>
</tr>
<tr><td><p>FatalErrorEventMask</p></td>
<td><p>Fatal error event (a fatal error was reported into ExceptionInfo)</p></td>
</tr>
<tr><td><p>AllEventsMask</p></td>
<td><p>All events (matches any/all events)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="logmethod">
<h1><a class="toc-backref" href="#id25">LogMethod</a></h1>
<p>LogMethod is a call-back function type in the form:</p>
<pre class="literal-block">typedef void (*LogMethod)(const ExceptionType type,const char *text)</pre>
</section>
<section id="logoutputtype">
<h1><a class="toc-backref" href="#id26">LogOutputType</a></h1>
<p>LogOutputType specifies how/where logging (&quot;tracing&quot;) output is to be directed.</p>
<table>
<caption>LogOutputType</caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>DisabledOutput</p></td>
<td><p>Reporting disabled</p></td>
</tr>
<tr><td><p>UndefinedOutput</p></td>
<td><p>Reporting disabled</p></td>
</tr>
<tr><td><p>StdoutOutput</p></td>
<td><p>Log to stdout in &quot;human readable&quot; format</p></td>
</tr>
<tr><td><p>StderrOutput</p></td>
<td><p>Log to stderr in &quot;human readable&quot; format</p></td>
</tr>
<tr><td><p>XMLFileOutput</p></td>
<td><p>Log to a file in an XML format</p></td>
</tr>
<tr><td><p>TXTFileOutput</p></td>
<td><p>Log to a file in a text format</p></td>
</tr>
<tr><td><p>Win32DebugOutput</p></td>
<td><p>Windows, Output events to the application/system debugger.</p></td>
</tr>
<tr><td><p>Win32EventlogOutput</p></td>
<td><p>Windows, Output events to the Application event log.</p></td>
</tr>
<tr><td><p>MethodOutput</p></td>
<td><p>Log by calling registered C-language callback function</p></td>
</tr>
</tbody>
</table>
</section>
<section id="image">
<h1><a class="toc-backref" href="#id27">Image</a></h1>
<p>The Image structure represents an GraphicsMagick image. It is initially
allocated by AllocateImage() and deallocated by DestroyImage(). The
functions ReadImage(), ReadImages(), BlobToImage() and CreateImage()
return a new image. Use CloneImage() to copy an image. An image consists
of a structure containing image attributes as well as the image pixels.</p>
<p>The image pixels are represented by the structure PixelPacket and are
cached in-memory, or on disk, depending on the cache threshold setting.
This cache is known as the &quot;pixel cache&quot;. Pixels in the cache may not be
edited directly. They must first be made visible from the cache via a
pixel view. A pixel view is a rectangular view of the pixels as defined
by a starting coordinate, and a number of rows and columns. When
considering the varying abilities of multiple platforms, the most
reliably efficient pixel view is comprized of part, or all, of one image
row.</p>
<p>There are two means of accessing pixel views. When using the default
view, the pixels are made visible and accessable by using the
GetImagePixels() method which provides access to a specified region of
the image. After the view has been updated, the pixels may be saved back
to the cache in their original positions via SyncImagePixels(). In order
to create an image with new contents, or to blindly overwrite existing
contents, the method SetImagePixels() is used to reserve a pixel view
corresponding to a region in the pixel cache. Once the pixel view has
been updated, it may be written to the cache via SyncImagePixels(). The
function GetIndexes() provides access to the image colormap, represented
as an array of type IndexPacket.</p>
<p>A more flexible interface to the image pixels is via the Cache View
interface. This interface supports multiple pixel cache views (limited by
the amount of available memory), each of which are identified by a handle
(of type ViewInfo). Use OpenCacheView() to obtain a new cache view,
CloseCacheView() to discard a cache view, GetCacheViewPixels() to access
an existing pixel region, SetCacheView() to define a new pixel region,
and SyncCacheViewPixels() to save the updated pixel region. The function
GetCacheViewIndexes() provides access to the colormap indexes associated
with the pixel view.</p>
<p>When writing encoders and decoders for new image formats, it is
convenient to have a high-level interface available which supports
converting between external pixel representations and GraphicsMagick's
own representation. Pixel components (red, green, blue, opacity, RGB, or
RGBA) may be transferred from a user-supplied buffer into the default
view by using ImportImagePixelArea(), or from an allocated view via
ImportViewPixelArea(). Pixel components may be transferred from the
default view into a user-supplied buffer by using ExportImagePixelArea(),
or from an allocated view via ExportViewPixelArea(). Use of this
high-level interface helps protect image coders from changes to
GraphicsMagick's pixel representation and simplifies the implementation.</p>
<p>The members of the Image structure are shown in the following table:</p>
<table>
<caption>Image Structure Members</caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 18%" />
<col style="width: 51%" />
</colgroup>
<tbody>
<tr><td><p>Member</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>background_color</p></td>
<td><p>PixelPacket</p></td>
<td><p>Image background color</p></td>
</tr>
<tr><td><p>blur</p></td>
<td><p>double</p></td>
<td><p>Blur factor to apply to the image when zooming</p></td>
</tr>
<tr><td><p>border_color</p></td>
<td><p>PixelPacket</p></td>
<td><p>Image border color</p></td>
</tr>
<tr><td><p>chromaticity</p></td>
<td><p>ChromaticityInfo</p></td>
<td><p>Red, green, blue, and white-point chromaticity
values.</p></td>
</tr>
<tr><td><p>colormap</p></td>
<td><p>PixelPacket *</p></td>
<td><p>PseudoColor palette array.</p></td>
</tr>
<tr><td><p>colors</p></td>
<td><p>unsigned int</p></td>
<td><p>The desired number of colors. Used by
QuantizeImage().</p></td>
</tr>
<tr><td><p>colorspace</p></td>
<td><p>ColorspaceType</p></td>
<td><p>Image pixel interpretation.If the colorspace is
RGB the pixels are red, green, blue. If matte is
true, then red, green, blue, and index. If it is
CMYK, the pixels are cyan, yellow, magenta, black.
Otherwise the colorspace is ignored.</p></td>
</tr>
<tr><td><p>columns</p></td>
<td><p>unsigned long</p></td>
<td><p>Image width</p></td>
</tr>
<tr><td><p>compression</p></td>
<td><p>CompressionType</p></td>
<td><p>Image compresion type. The default is the
compression type of the specified image file.</p></td>
</tr>
<tr><td><p>delay</p></td>
<td><p>unsigned long</p></td>
<td><p>Time in 1/100ths of a second (0 to 65535) which
must expire before displaying the next image in an
animated sequence. This option is useful for
regulating the animation of a sequence of GIF
images within Netscape.</p></td>
</tr>
<tr><td><p>depth</p></td>
<td><p>unsigned int</p></td>
<td><p>Image depth.  Number of encoding bits per sample.
Usually 8 or 16, but sometimes 10 or 12.</p></td>
</tr>
<tr><td><p>directory</p></td>
<td><p>char *</p></td>
<td><p>Tile names from within an image montage. Only
valid after calling MontageImages() or reading a
MIFF file which contains a directory.</p></td>
</tr>
<tr><td><p>dispose</p></td>
<td><p>DisposeType</p></td>
<td><p>GIF disposal method. This option is used to
control how successive frames are rendered (how
the preceding frame is disposed of) when creating
a GIF animation.</p></td>
</tr>
<tr><td><p>endian</p></td>
<td><p>EndianType</p></td>
<td><p>The byte order to use when writing images.</p></td>
</tr>
<tr><td><p>exception</p></td>
<td><p>ExceptionInfo</p></td>
<td><p>Record of any error which occurred when updating
image.</p></td>
</tr>
<tr><td><p>filename</p></td>
<td><p>char
[MaxTextExtent]</p></td>
<td><p>Image file name to read or write.</p></td>
</tr>
<tr><td><p>filter</p></td>
<td><p>FilterTypes</p></td>
<td><p>Filter to use when resizing image. The reduction
filter employed has a significant effect on the
time required to resize an image and the resulting
quality. The default filter is Lanczos which has
been shown to produce high quality results when
reducing most images.</p></td>
</tr>
<tr><td><p>fuzz</p></td>
<td><p>double</p></td>
<td><p>Colors within this distance are considered equal.
A number of algorithms search for a target color.
By default the color must be exact. Use this
option to match colors that are close to the
target color in RGB space.</p></td>
</tr>
<tr><td><p>gamma</p></td>
<td><p>double</p></td>
<td><p>Gamma level of the image. The same color image
displayed on two different workstations may look
different due to differences in the display
monitor. Use gamma correction to adjust for this
color difference.</p></td>
</tr>
<tr><td><p>geometry</p></td>
<td><p>char *</p></td>
<td><p>Preferred size of the image when encoding.</p></td>
</tr>
<tr><td><p>gravity</p></td>
<td><p>GravityType</p></td>
<td><p>Positioning of the image within a bounding region.</p></td>
</tr>
<tr><td><p>interlace</p></td>
<td><p>InterlaceType</p></td>
<td><p>The type of interlacing scheme (default
NoInterlace). This option is used to specify the
type of interlacing scheme for raw image formats
such as RGB or YUV. NoInterlace means do not
interlace, LineInterlace uses scanline
interlacing, and PlaneInterlace uses plane
interlacing. PartitionInterlace is like
PlaneInterlace except the different planes are
saved to individual files (e.g. image.R, image.G,
and image.B). Use LineInterlace or PlaneInterlace
to create an interlaced GIF or progressive JPEG
image.</p></td>
</tr>
<tr><td><p>iterations</p></td>
<td><p>unsigned long</p></td>
<td><p>Number of iterations to loop an animation (e.g.
Netscape loop extension) for.</p></td>
</tr>
<tr><td><p>magick</p></td>
<td><p>char
[MaxTextExtent]</p></td>
<td><p>Image encoding format (e.g. &quot;GIF&quot;).</p></td>
</tr>
<tr><td><p>magick_columns</p></td>
<td><p>unsigned long</p></td>
<td><p>Base image width (before transformations)</p></td>
</tr>
<tr><td><p>magick_filename</p></td>
<td><p>char
[MaxTextExtent]</p></td>
<td><p>Base image filename (before transformations)</p></td>
</tr>
<tr><td><p>magick_rows</p></td>
<td><p>unsigned long</p></td>
<td><p>Base image height (before transformations)</p></td>
</tr>
<tr><td><p>matte</p></td>
<td><p>MagickBool</p></td>
<td><p>If true, then the index member of pixels
represents the alpha channel.</p></td>
</tr>
<tr><td><p>matte_color</p></td>
<td><p>PixelPacket</p></td>
<td><p>Image matte (transparent) color</p></td>
</tr>
<tr><td><p>montage</p></td>
<td><p>char *</p></td>
<td><p>Tile size and offset within an image montage. Only
valid for montage images.</p></td>
</tr>
<tr><td><p>next</p></td>
<td><p>struct _Image *</p></td>
<td><p>Next image frame in sequence</p></td>
</tr>
<tr><td><p>offset</p></td>
<td><p>long</p></td>
<td><p>Number of initial bytes to skip over when reading
raw image.</p></td>
</tr>
<tr><td><p>orientation</p></td>
<td><p>OrientationType</p></td>
<td><p>Orientation of the image. Specifies scanline
orientation and starting coordinate of image.</p></td>
</tr>
<tr><td><p>page</p></td>
<td><p>RectangleInfo</p></td>
<td><p>Equivalent size of Postscript page.</p></td>
</tr>
<tr><td><p>previous</p></td>
<td><p>struct _Image *</p></td>
<td><p>Previous image frame in sequence.</p></td>
</tr>
<tr><td><p>rendering_intent</p></td>
<td><p>RenderingIntent</p></td>
<td><p>The type of rendering intent.</p></td>
</tr>
<tr><td><p>rows</p></td>
<td><p>unsigned long</p></td>
<td><p>Image height</p></td>
</tr>
<tr><td><p>scene</p></td>
<td><p>unsigned long</p></td>
<td><p>Image frame scene number.</p></td>
</tr>
<tr><td><p>start_loop</p></td>
<td><p>long</p></td>
<td><p>Animation frame number to start looping at.</p></td>
</tr>
<tr><td><p>storage_class</p></td>
<td><p>ClassType</p></td>
<td><p>Image storage class. If DirectClass then the image
packets contain valid RGB or CMYK colors. If
PseudoClass then the image has a colormap
referenced by pixel's index member.</p></td>
</tr>
<tr><td><p>tile_info</p></td>
<td><p>RectangleInfo</p></td>
<td><p>Describes a tile within an image.  For example, if
your images is 640x480 you may only want 320x256
with an offset of +128+64. It is used for raw
formats such as RGB and CMYK as well as for TIFF.</p></td>
</tr>
<tr><td><p>timer</p></td>
<td><p>TimerInfo</p></td>
<td><p>Support for measuring actual (user + system) and
elapsed execution time.</p></td>
</tr>
<tr><td><p>total_colors</p></td>
<td><p>unsigned long</p></td>
<td><p>The number of colors in the image after
QuantizeImage(), or QuantizeImages() if the
verbose flag was set before the call. Calculated
by GetNumberColors().</p></td>
</tr>
<tr><td><p>units</p></td>
<td><p>ResolutionType</p></td>
<td><p>Units of image resolution</p></td>
</tr>
<tr><td><p>x_resolution</p></td>
<td><p>double</p></td>
<td><p>Horizontal resolution of the image</p></td>
</tr>
<tr><td><p>y_resolution</p></td>
<td><p>double</p></td>
<td><p>Vertical resolution of the image</p></td>
</tr>
</tbody>
</table>
</section>
<section id="imageinfo">
<h1><a class="toc-backref" href="#id28">ImageInfo</a></h1>
<p>The ImageInfo structure is used to supply option information to the
functions AllocateImage(), AnimateImages(), BlobToImage(),
CloneAnnotateInfo(), DisplayImages(), GetAnnotateInfo(), ImageToBlob(),
PingImage(), ReadImage(), ReadImages(), and, WriteImage(). These
functions update information in ImageInfo to reflect the attributes of
the current image.</p>
<p>Use CloneImageInfo() to duplicate an existing ImageInfo structure or
allocate a new one. Use DestroyImageInfo() to deallocate memory
associated with an ImageInfo structure. Use GetImageInfo() to initialize
an existing ImageInfo structure. Use SetImageInfo() to set image type
information in the ImageInfo structure based on an existing image.</p>
<p>The members of the ImageInfo structure are shown in the following table:</p>
<table>
<caption>ImageInfo Structure Members</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 15%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr><td><p>Member</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>adjoin</p></td>
<td><p>MagickBool</p></td>
<td><p>Join images into a single multi-image file.</p></td>
</tr>
<tr><td><p>antialias</p></td>
<td><p>MagickBool</p></td>
<td><p>Control antialiasing of rendered Postscript and Postscript or
TrueType fonts. Enabled by default.</p></td>
</tr>
<tr><td><p>background_color</p></td>
<td><p>PixelPacket</p></td>
<td><p>Image background color.</p></td>
</tr>
<tr><td><p>border_color</p></td>
<td><p>PixelPacket</p></td>
<td><p>Image border color.</p></td>
</tr>
<tr><td><p>colorspace</p></td>
<td><p>ColorspaceType</p></td>
<td><p>Image pixel interpretation.If the colorspace is RGB the pixels are
red, green, blue. If matte is true, then red, green, blue, and
index. If it is CMYK, the pixels are cyan, yellow, magenta, black.
Otherwise the colorspace is ignored.</p></td>
</tr>
<tr><td><p>compression</p></td>
<td><p>CompressionType</p></td>
<td><p>Image compresion type. The default is the compression type of the
specified image file.</p></td>
</tr>
<tr><td><p>density</p></td>
<td><p>char *</p></td>
<td><p>Vertical and horizontal resolution in pixels of the image. This
option specifies an image density when decoding a Postscript or
Portable Document page. Often used with page.</p></td>
</tr>
<tr><td><p>depth</p></td>
<td><p>unsigned long</p></td>
<td><p>Image depth (8 or 16). QuantumLeap must be defined before a depth
of 16 is valid.</p></td>
</tr>
<tr><td><p>dither</p></td>
<td><p>MagickBool</p></td>
<td><p>Apply Floyd/Steinberg error diffusion to the image. The basic
strategy of dithering is to trade intensity resolution for spatial
resolution by averaging the intensities of several neighboring
pixels. Images which suffer from severe contouring when reducing
colors can be improved with this option. The colors or monochrome
option must be set for this option to take effect.</p></td>
</tr>
<tr><td><p>file</p></td>
<td><p>FILE *</p></td>
<td><p>Stdio stream to read image from or write image to. If set,
ImageMagick will read from or write to the stream rather than
opening a file. Used by ReadImage() and WriteImage(). The stream is
closed when the operation completes.</p></td>
</tr>
<tr><td><p>filename</p></td>
<td><p>char
[MaxTextExtent]</p></td>
<td><p>Image file name to read or write.</p></td>
</tr>
<tr><td><p>font</p></td>
<td><p>char *</p></td>
<td><p>Text rendering font. If the font is a fully qualified X server font
name, the font is obtained from an X server. To use a TrueType
font, precede the TrueType filename with an &#64;. Otherwise, specify a
Postscript font name (e.g. &quot;helvetica&quot;).</p></td>
</tr>
<tr><td><p>fuzz</p></td>
<td><p>double</p></td>
<td><p>Colors within this distance are considered equal. A number of
algorithms search for a target color. By default the color must be
exact. Use this option to match colors that are close to the target
color in RGB space.</p></td>
</tr>
<tr><td><p>interlace</p></td>
<td><p>InterlaceType</p></td>
<td><p>The type of interlacing scheme (default NoInterlace). This option
is used to specify the type of interlacing scheme for raw image
formats such as RGB or YUV. NoInterlace means do not interlace,
LineInterlace uses scanline interlacing, and PlaneInterlace uses
plane interlacing. PartitionInterlace is like PlaneInterlace except
the different planes are saved to individual files (e.g. image.R,
image.G, and image.B). Use LineInterlace or PlaneInterlace to
create an interlaced GIF or progressive JPEG image.</p></td>
</tr>
<tr><td><p>magick</p></td>
<td><p>char
[MaxTextExtent]</p></td>
<td><p>Image encoding format (e.g. &quot;GIF&quot;).</p></td>
</tr>
<tr><td><p>matte_color</p></td>
<td><p>PixelPacket</p></td>
<td><p>Image matte (transparent) color.</p></td>
</tr>
<tr><td><p>monochrome</p></td>
<td><p>MagickBool</p></td>
<td><p>Transform the image to black and white.</p></td>
</tr>
<tr><td><p>page</p></td>
<td><p>char *</p></td>
<td><p>Equivalent size of Postscript page.</p></td>
</tr>
<tr><td><p>pen</p></td>
<td><p>PixelPacket</p></td>
<td><p>Drawing object stroke or fill color.</p></td>
</tr>
<tr><td><p>pointsize</p></td>
<td><p>double</p></td>
<td><p>Text rendering font point size.</p></td>
</tr>
<tr><td><p>quality</p></td>
<td><p>unsigned long</p></td>
<td><p>JPEG/MIFF/PNG compression level (default 75).</p></td>
</tr>
<tr><td><p>server_name</p></td>
<td><p>char *</p></td>
<td><p>X11 display to display to obtain fonts from, or to capture image
from.</p></td>
</tr>
<tr><td><p>size</p></td>
<td><p>char *</p></td>
<td><p>Width and height of a raw image (an image which does not support
width and height information). Size may also be used to affect the
image size read from a multi-resolution format, such as Photo CD,
JBIG, or JPEG.</p></td>
</tr>
<tr><td><p>subimage</p></td>
<td><p>unsigned long</p></td>
<td><p>Subimage of an image sequence.</p></td>
</tr>
<tr><td><p>subrange</p></td>
<td><p>unsigned long</p></td>
<td><p>Number of images relative to the base image.</p></td>
</tr>
<tr><td><p>texture</p></td>
<td><p>char *</p></td>
<td><p>Image filename to use as background texture.</p></td>
</tr>
<tr><td><p>tile</p></td>
<td><p>char *</p></td>
<td><p>Tile name.</p></td>
</tr>
<tr><td><p>units</p></td>
<td><p>ResolutionType</p></td>
<td><p>Units of image resolution.</p></td>
</tr>
<tr><td><p>verbose</p></td>
<td><p>unsigned int</p></td>
<td><p>Print detailed information about the image if True.</p></td>
</tr>
<tr><td><p>view</p></td>
<td><p>char *</p></td>
<td><p>FlashPix viewing parameters.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="imagetype">
<h1><a class="toc-backref" href="#id29">ImageType</a></h1>
<p>ImageType indicates the type classification of the image.</p>
<table>
<caption>ImageType</caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedType</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>BilevelType</p></td>
<td><p>Monochrome image</p></td>
</tr>
<tr><td><p>GrayscaleType</p></td>
<td><p>Grayscale image</p></td>
</tr>
<tr><td><p>GrayscaleMatteType</p></td>
<td><p>Grayscale image with opacity</p></td>
</tr>
<tr><td><p>PaletteType</p></td>
<td><p>Indexed color (palette) image</p></td>
</tr>
<tr><td><p>PaletteMatteType</p></td>
<td><p>Indexed color (palette) image with opacity</p></td>
</tr>
<tr><td><p>TrueColorType</p></td>
<td><p>Truecolor image</p></td>
</tr>
<tr><td><p>TrueColorMatteType</p></td>
<td><p>Truecolor image with opacity</p></td>
</tr>
<tr><td><p>ColorSeparationType</p></td>
<td><p>Cyan/Yellow/Magenta/Black (CYMK) image</p></td>
</tr>
<tr><td><p>ColorSeparationMatteType</p></td>
<td><p>Cyan/Yellow/Magenta/Black (CYMK) image with opacity</p></td>
</tr>
</tbody>
</table>
</section>
<section id="indexpacket">
<h1><a class="toc-backref" href="#id30">IndexPacket</a></h1>
<p>IndexPacket is the type used for a colormap index. An array of type
IndexPacket is used to represent an image in PseudoClass type. Currently
supported IndexPacket underlying types are 'unsigned char', 'unsigned short',
and 'unsigned int'. The type is selected at build time according to the
QuantumDepth setting.</p>
<pre class="literal-block">typedef Quantum IndexPacket;</pre>
</section>
<section id="interlacetype">
<h1><a class="toc-backref" href="#id31">InterlaceType</a></h1>
<p>InterlaceType specifies the ordering of the red, green, and blue pixel
information in the image. Interlacing is usually used to make image
information available to the user faster by taking advantage of the space
vs time tradeoff. For example, interlacing allows images on the Web to be
recognizable sooner and satellite images to accumulate/render with image
resolution increasing over time.</p>
<p>Use LineInterlace or PlaneInterlace to create an interlaced GIF or
progressive JPEG image.</p>
<table>
<caption>InterlaceType</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedInterlace</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>NoInterlace</p></td>
<td><p>Don't interlace image (RGBRGBRGBRGBRGBRGB...)</p></td>
</tr>
<tr><td><p>LineInterlace</p></td>
<td><p>Use scanline interlacing (RRR...GGG...BBB...RRR...GGG...BBB...)</p></td>
</tr>
<tr><td><p>PlaneInterlace</p></td>
<td><p>Use plane interlacing (RRRRRR...GGGGGG...BBBBBB...)</p></td>
</tr>
<tr><td><p>PartitionInterlace</p></td>
<td><p>Similar to plane interlaing except that the different planes are saved to
individual files (e.g. image.R, image.G, and image.B)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="layertype">
<h1><a class="toc-backref" href="#id32">LayerType</a></h1>
<p>LayerType is used as an argument when doing color separations. Use
LayerType when extracting a layer from an image. MatteLayer is useful for
extracting the opacity values from an image.</p>
<table>
<caption>LayerType</caption>
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedLayer</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>RedLayer</p></td>
<td><p>Select red layer</p></td>
</tr>
<tr><td><p>GreenLayer</p></td>
<td><p>Select green layer</p></td>
</tr>
<tr><td><p>BlueLayer</p></td>
<td><p>Select blue layer</p></td>
</tr>
<tr><td><p>MatteLayer</p></td>
<td><p>Select matte (opacity values) layer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="magickinfo">
<h1><a class="toc-backref" href="#id33">MagickInfo</a></h1>
<p>The MagickInfo structure is used by GraphicsMagick to register support
for an image format. The MagickInfo structure is allocated with default
parameters by calling SetMagickInfo(). Image formats are registered by
calling RegisterMagickInfo() which adds the initial structure to a linked
list (at which point it is owned by the list). A pointer to the structure
describing a format may be obtained by calling GetMagickInfo(). Pass the
argument NULL to obtain the first member of this list. A human-readable
list of registered image formats may be printed to a file descriptor by
calling ListMagickInfo().</p>
<p>Support for formats may be provided as a module which is part of the
GraphicsMagick library, provided by a module which is loaded dynamically
at run-time, or directly by the linked program. Users of GraphicsMagick
will normally want to create a loadable-module, or support encode/decode
of an image format directly from within their program.</p>
<p>Sample Module:</p>
<p>The following shows sample code for a module called &quot;GIF&quot; (gif.c). Note
that the names of the Register and Unregister callback routines are
calculated at run-time, and therefore must follow the rigid naming scheme
RegisterFORMATImage and UnregisterFORMATImage, respectively, where FORMAT
is the upper-cased name of the module file:</p>
<pre class="literal-block">/* Read image */
Image *ReadGIFImage(const ImageInfo *image_info)
{
  [ decode the image ... ]
}

/* Write image */
unsigned int WriteGIFImage(const ImageInfo *image_info,Image *image)
{
  [ encode the image ... ]
}

/* Module call-back to register support for formats */
void RegisterGIFImage(void)
{
  MagickInfo *entry;
  entry=SetMagickInfo(&quot;GIF&quot;);
  entry-&gt;decoder=ReadGIFImage;
  entry-&gt;encoder=WriteGIFImage;
  entry-&gt;description=&quot;CompuServe graphics interchange format&quot;;
  entry-&gt;module=&quot;GIF&quot;;
  RegisterMagickInfo(entry);

  entry=SetMagickInfo(&quot;GIF87&quot;);
  entry-&gt;decoder=ReadGIFImage;
  entry-&gt;encoder=WriteGIFImage;
  entry-&gt;adjoin=False;
  entry-&gt;description=&quot;CompuServe graphics interchange format (version 87a)&quot;;
  entry-&gt;module=&quot;GIF&quot;;
  RegisterMagickInfo(entry);
}

/* Module call-back to unregister support for formats */
Export void UnregisterGIFImage(void)
{
  UnregisterMagickInfo(&quot;GIF&quot;);
  UnregisterMagickInfo(&quot;GIF87&quot;);
}</pre>
<p>Sample Application Code</p>
<p>Image format support provided within the user's application does not need
to implement the RegisterFORMATImage and UnregisterFORMATImage callback
routines. Instead, the application takes responsibility for the
registration itself. An example follows:</p>
<pre class="literal-block">/* Read image */
Image *ReadGIFImage(const ImageInfo *image_info)
{
  [ decode the image ... ]
}
/* Write image */
unsigned int WriteGIFImage(const ImageInfo *image_info,Image *image)
{
  [ encode the image ... ]
}
#include &lt;stdio.h&gt;
int main( void )
{
  struct MagickInfo* info;
  info = SetMagickInfo(&quot;GIF&quot;);
  if ( info == (MagickInfo*)NULL )
  exit(1);
  info-&gt;decoder = ReadGIFImage;
  info-&gt;encoder = WriteGIFImage;
  info-&gt;adjoin = False;
  info-&gt;description = &quot;CompuServe graphics interchange format&quot;;
  /* Add MagickInfo structure to list */
  RegisterMagickInfo(info);
  info = GetMagickInfo(&quot;GIF&quot;);
  [ do something with info ... ]
  ListMagickInfo( stdout );
  return;
}</pre>
<p>MagickInfo Structure Definition</p>
<p>The members of the MagickInfo structure are shown in the following table:</p>
<table>
<caption>MagickInfo Structure Members</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 20%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr><td><p>Member</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>adjoin</p></td>
<td><p>MagickBool</p></td>
<td><p>Set to non-zero (True) if this file format supports multi-frame
images.</p></td>
</tr>
<tr><td><p>blob_support</p></td>
<td><p>MagickBool</p></td>
<td><p>Set to non-zero (True) if the encoder and decoder for this format
supports operating on arbitrary BLOBs (rather than only disk
files).</p></td>
</tr>
<tr><td><p>client_data</p></td>
<td><p>void *</p></td>
<td><p>User specified data. A way to pass any sort of data structure to
the endoder/decoder. To set this, GetMagickInfo() must be called
to first obtain a pointer to the registered structure since it can
not be set via a RegisterMagickInfo() parameter.</p></td>
</tr>
<tr><td><p>coder_class</p></td>
<td><p>CoderClass</p></td>
<td><p>Image format coder stability level.</p></td>
</tr>
<tr><td><p>decoder</p></td>
<td><p>Image *(*decoder)
(const ImageInfo
*)</p></td>
<td><p>Function to decode image data and return GraphicsMagick Image.</p></td>
</tr>
<tr><td><p>description</p></td>
<td><p>char *</p></td>
<td><p>Long form image format description (e.g. &quot;CompuServe graphics
interchange format&quot;).</p></td>
</tr>
<tr><td><p>encoder</p></td>
<td><p>unsigned int
(*encoder)(const
ImageInfo *, Image
*)</p></td>
<td><p>Function to encode image data with options passed via ImageInfo
and image represented by Image.</p></td>
</tr>
<tr><td><p>module</p></td>
<td><p>char *</p></td>
<td><p>Name of module (e.g. &quot;GIF&quot;) which registered this format. Set to
NULL if format is not registered by a module.</p></td>
</tr>
<tr><td><p>name</p></td>
<td><p>const char *</p></td>
<td><p>Magick string (e.g. &quot;GIF&quot;) which identifies this format.</p></td>
</tr>
<tr><td><p>next</p></td>
<td><p>MagickInfo</p></td>
<td><p>Next MagickInfo struct in linked-list. NULL if none.</p></td>
</tr>
<tr><td><p>note</p></td>
<td><p>const char *</p></td>
<td><p>Usage note for users.</p></td>
</tr>
<tr><td><p>previous</p></td>
<td><p>MagickInfo</p></td>
<td><p>Previous MagickInfo struct in linked-list. NULL if none.</p></td>
</tr>
<tr><td><p>stealth</p></td>
<td><p>MagickBook</p></td>
<td><p>Image format should not appear appear in format listings.</p></td>
</tr>
<tr><td><p>raw</p></td>
<td><p>MagickBool</p></td>
<td><p>Image format does not contain size (must be specified in
ImageInfo).</p></td>
</tr>
<tr><td><p>version</p></td>
<td><p>const char *</p></td>
<td><p>Version of the support library used for the format.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="monitorhandler">
<h1><a class="toc-backref" href="#id34">MonitorHandler</a></h1>
<p>MonitorHandler is the function type to be used for the progress monitor
callback. Its definition is as follows:</p>
<pre class="literal-block">typedef unsigned int
  (*MonitorHandler)(const char *text, const magick_int64_t quantum,
    const magick_uint64_t span, ExceptionInfo *exception);</pre>
<p>A MonitorHandler should normally return True (a non-zero value) if the
operation can continue.  If it returns False, then the operation will be
aborted.  This mechanism enables a user to terminate a process that is
taking too long to complete.</p>
<p>The operation of the monitor handler is described in the following table:</p>
<table>
<caption>MonitorHandler Parameters</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 49%" />
</colgroup>
<tbody>
<tr><td><p>Parameter</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>text</p></td>
<td><p>const char *</p></td>
<td><p>A description of the current operation being
performed.</p></td>
</tr>
<tr><td><p>quantum</p></td>
<td><p>const magick_int64_t</p></td>
<td><p>A value within the range of 0 to <em>span</em> which
indicates the degree of progress.</p></td>
</tr>
<tr><td><p>span</p></td>
<td><p>const magick_uint64_t</p></td>
<td><p>The total range that quantum will span.</p></td>
</tr>
<tr><td><p>exception</p></td>
<td><p>exceptionInfo *</p></td>
<td><p>If the progress monitor returns False (abort
operation), it should also update the
structure passed via the exception parameter
so that an error message may be reported to
the user.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="montageinfo">
<h1><a class="toc-backref" href="#id35">MontageInfo</a></h1>
<pre class="literal-block">typedef struct _MontageInfo
{
  char
    *geometry,
    *tile,
    *title,
    *frame,
    *texture,
    *font;

  double
    pointsize;

  unsigned long
    border_width;

  unsigned int
    shadow;

  PixelPacket
    fill,
    stroke,
    background_color,
    border_color,
    matte_color;

  GravityType
    gravity;

  char
    filename[MaxTextExtent];

  unsigned long
    signature;
} MontageInfo;</pre>
</section>
<section id="noisetype">
<h1><a class="toc-backref" href="#id36">NoiseType</a></h1>
<p>NoiseType is used as an argument to select the type of noise to be added
to the image.</p>
<table>
<caption>NoiseType</caption>
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UniformNoise</p></td>
<td><p>Uniform noise</p></td>
</tr>
<tr><td><p>GaussianNoise</p></td>
<td><p>Gaussian noise</p></td>
</tr>
<tr><td><p>MultiplicativeGaussianNoise</p></td>
<td><p>Multiplicative Gaussian noise</p></td>
</tr>
<tr><td><p>ImpulseNoise</p></td>
<td><p>Impulse noise</p></td>
</tr>
<tr><td><p>LaplacianNoise</p></td>
<td><p>Laplacian noise</p></td>
</tr>
<tr><td><p>PoissonNoise</p></td>
<td><p>Poisson noise</p></td>
</tr>
<tr><td><p>RandomNoise</p></td>
<td><p>Random noise (uniform distribution)</p></td>
</tr>
<tr><td><p>UndefinedNoise</p></td>
<td><p>Undefined noise</p></td>
</tr>
</tbody>
</table>
</section>
<section id="orientationtype">
<h1><a class="toc-backref" href="#id37">OrientationType</a></h1>
<p>OrientationType specifies the orientation of the image. Useful for when
the image is produced via a different ordinate system, the camera was
turned on its side, or the page was scanned sideways.</p>
<table>
<caption>OrientationType</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 29%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Scanline Direction</p></td>
<td><p>Frame Direction</p></td>
</tr>
<tr><td><p>UndefinedOrientation</p></td>
<td><p>Unknown</p></td>
<td><p>Unknown</p></td>
</tr>
<tr><td><p>TopLeftOrientation</p></td>
<td><p>Left to right</p></td>
<td><p>Top to bottom</p></td>
</tr>
<tr><td><p>TopRightOrientation</p></td>
<td><p>Right to left</p></td>
<td><p>Top to bottom</p></td>
</tr>
<tr><td><p>BottomRightOrientation</p></td>
<td><p>Right to left</p></td>
<td><p>Bottom to top</p></td>
</tr>
<tr><td><p>BottomLeftOrientation</p></td>
<td><p>Left to right</p></td>
<td><p>Bottom to top</p></td>
</tr>
<tr><td><p>LeftTopOrientation</p></td>
<td><p>Top to bottom</p></td>
<td><p>Left to right</p></td>
</tr>
<tr><td><p>RightTopOrientation</p></td>
<td><p>Top to bottom</p></td>
<td><p>Right to left</p></td>
</tr>
<tr><td><p>RightBottomOrientation</p></td>
<td><p>Bottom to top</p></td>
<td><p>Right to left</p></td>
</tr>
<tr><td><p>LeftBottomOrientation</p></td>
<td><p>Bottom to top</p></td>
<td><p>Left to right</p></td>
</tr>
</tbody>
</table>
</section>
<section id="paintmethod">
<h1><a class="toc-backref" href="#id38">PaintMethod</a></h1>
<p>PaintMethod specifies how pixel colors are to be replaced in the image.
It is used to select the pixel-filling algorithm employed.</p>
<table>
<caption>PaintMethod</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>PointMethod</p></td>
<td><p>Replace pixel color at point.</p></td>
</tr>
<tr><td><p>ReplaceMethod</p></td>
<td><p>Replace color for all image pixels matching color at point.</p></td>
</tr>
<tr><td><p>FloodfillMethod</p></td>
<td><p>Replace color for pixels surrounding point until encountering pixel that
fails to match color at point.</p></td>
</tr>
<tr><td><p>FillToBorderMethod</p></td>
<td><p>Replace color for pixels surrounding point until encountering pixels matching
border color.</p></td>
</tr>
<tr><td><p>ResetMethod</p></td>
<td><p>Replace colors for all pixels in image with pen color.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="pixelpacket">
<h1><a class="toc-backref" href="#id39">PixelPacket</a></h1>
<p>The PixelPacket structure is used to represent DirectClass color
pixels in GraphicsMagick. If the image is indicated as a PseudoClass
image, its DirectClass representation is only assured to be valid
immediately after calling SyncImage(), although it is usually already
valid and the convention is to assure that the DirectClass
representation is updated. If an image is set as PseudoClass and the
DirectClass representation is modified, the image should then be set
as DirectClass.  Use QuantizeImage() to restore the PseudoClass
colormap if the DirectClass representation is modified.</p>
<p>The members of the PixelPacket structure are shown in the following table:</p>
<table>
<caption>PixelPacket Structure Members</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 10%" />
<col style="width: 24%" />
<col style="width: 33%" />
<col style="width: 23%" />
</colgroup>
<tbody>
<tr><td rowspan="2"><p>Member</p></td>
<td rowspan="2"><p>Type</p></td>
<td colspan="3"><p>Interpretation</p></td>
</tr>
<tr><td><p>RGBColorspace (3)</p></td>
<td><p>RGBColorspace + matte(3)</p></td>
<td><p>CMYKColorspace</p></td>
</tr>
<tr><td><p>red</p></td>
<td><p>Quantum</p></td>
<td><p>Red</p></td>
<td><p>Red</p></td>
<td><p>Cyan</p></td>
</tr>
<tr><td><p>green</p></td>
<td><p>Quantum</p></td>
<td><p>Green</p></td>
<td><p>Green</p></td>
<td><p>Magenta</p></td>
</tr>
<tr><td><p>blue</p></td>
<td><p>Quantum</p></td>
<td><p>Blue</p></td>
<td><p>Blue</p></td>
<td><p>Yellow</p></td>
</tr>
<tr><td><p>opacity</p></td>
<td><p>Quantum</p></td>
<td><p>Ignored</p></td>
<td><p>Opacity</p></td>
<td><p>Black</p></td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<blockquote>
<ol class="arabic simple">
<li><p>Quantum is an unsigned short (MaxRGB=65535) if GraphicsMagick is
built using -DQuantumDepth=16 Otherwise it is an unsigned char
(MaxRGB=255).</p></li>
<li><p>SyncImage() may be used to synchronize the DirectClass color pixels
to the current PseudoClass colormap.</p></li>
<li><p>For pixel representation purposes, all colorspaces are treated like
RGBColorspace except for CMYKColorspace.</p></li>
</ol>
</blockquote>
</section>
<section id="pointinfo">
<h1><a class="toc-backref" href="#id40">PointInfo</a></h1>
<p>The PointInfo structure is used by the ChromaticityInfo structure to
specify chromaticity point values. This defines the boundaries and gammut
(range of included color) of the colorspace.</p>
<p>The members of the PointInfo structure are shown in the following table:</p>
<table>
<caption>PointInfo Structure Members</caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 25%" />
<col style="width: 44%" />
</colgroup>
<tbody>
<tr><td><p>Member</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>x</p></td>
<td><p>double</p></td>
<td><p>X ordinate</p></td>
</tr>
<tr><td><p>y</p></td>
<td><p>double</p></td>
<td><p>Y ordinate</p></td>
</tr>
</tbody>
</table>
</section>
<section id="profileinfo">
<h1><a class="toc-backref" href="#id41">ProfileInfo</a></h1>
<p>The ProfileInfo structure is used to represent ICC or IPCT profiles in
GraphicsMagick (stored as an opaque BLOB).</p>
<p>The members of the ProfileInfo structure are shown in the following table:</p>
<table>
<caption>ProfileInfo Structure Members</caption>
<colgroup>
<col style="width: 24%" />
<col style="width: 40%" />
<col style="width: 36%" />
</colgroup>
<tbody>
<tr><td><p>Member</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>length</p></td>
<td><p>size_t</p></td>
<td><p>Profile length</p></td>
</tr>
<tr><td><p>name</p></td>
<td><p>char *</p></td>
<td><p>Profile name</p></td>
</tr>
<tr><td><p>info</p></td>
<td><p>unsigned char *</p></td>
<td><p>Profile data</p></td>
</tr>
</tbody>
</table>
</section>
<section id="quantizeinfo">
<h1><a class="toc-backref" href="#id42">QuantizeInfo</a></h1>
<p>The QuantizeInfo structure is used to support passing parameters to
GraphicsMagick's color quantization (reduction) functions. Color
quantization is the process of analyzing one or more images, and
calculating a color palette which best approximates the image within a
specified colorspace, and then adjusting the image pixels to use the
calculated color palette. The maximum number of colors allowed in the
color palette may be specified.</p>
<table>
<caption>Methods Supporting QuantizeInfo</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr><td><p>Method</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>GetQuantizeInfo()</p></td>
<td><p>Allocate new structure with defaults set.</p></td>
</tr>
<tr><td><p>CloneQuantizeInfo()</p></td>
<td><p>Copy existing structure, allocating new structure in the process.</p></td>
</tr>
<tr><td><p>DestroyQuantizeInfo
()</p></td>
<td><p>Deallocate structure, including any members.</p></td>
</tr>
<tr><td><p>QuantizeImage</p></td>
<td><p>Analyzes the colors within a reference image and chooses a fixed number of
colors to represent the image.</p></td>
</tr>
<tr><td><p>QuantizeImages</p></td>
<td><p>Analyzes the colors within a set of reference images and chooses a fixed
number of colors to represent the set.</p></td>
</tr>
</tbody>
</table>
<table>
<caption>QuantizeInfo Structure Members</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 14%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr><td><p>Member</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>colorspace</p></td>
<td><p>ColorspaceType</p></td>
<td><p>The colorspace to quantize in. Color reduction, by default, takes
place in the RGB color space.  Empirical  evidence  suggests that
distances in color spaces such as YUV or YIQ  correspond  to
perceptual  color differences more closely  than  do distances in RGB
space. The Transparent color space behaves uniquely in that it
preserves the matte channel of the image if it exists.</p></td>
</tr>
<tr><td><p>dither</p></td>
<td><p>unsigned int</p></td>
<td><p>Set to True (non-zero) to apply Floyd/Steinberg error diffusion to the
image. When the size of the color palette is less than the image
colors, this trades off spacial resolution for color resolution by
dithering to achieve a similar looking image.</p></td>
</tr>
<tr><td><p>measure_error</p></td>
<td><p>unsigned int</p></td>
<td><p>Set to True (non-zero) to calculate quantization errors when
quantizing the image.</p></td>
</tr>
<tr><td><p>number_colors</p></td>
<td><p>unsigned long</p></td>
<td><p>Specify the maximum number of colors in the output image. Must be
equal to, or less than MaxRGB, which is determined by the value of
QuantumLeap when GraphicsMagick was compiled.</p></td>
</tr>
<tr><td><p>signature</p></td>
<td><p>unsigned long</p></td>
<td><p>???</p></td>
</tr>
<tr><td><p>tree_depth</p></td>
<td><p>unsigned int</p></td>
<td><p>Specify the tree depth to use while quantizing. The values zero and
one support automatic tree depth determination. The tree depth may be
forced via values ranging from two to eight. The ideal tree depth
depends on the characteristics of the input image, and may be
determined through experimentation.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="quantum">
<h1><a class="toc-backref" href="#id43">Quantum</a></h1>
<p>Quantum is the base type used to store a pixel component, such as the
'R' in an RGB pixel.  It can be defined as either an 'unsigned char',
'unsigned short', or an 'unsigned int'.</p>
</section>
<section id="quantumtype">
<h1><a class="toc-backref" href="#id44">QuantumType</a></h1>
<p>QuantumType is used to indicate the source or destination format of
entire pixels, or components of pixels (&quot;Quantums&quot;) while they are being
read, or written to, a pixel cache. The validity of these format
specifications depends on whether the Image pixels are in RGB format,
RGBA format, or CMYK format. The pixel Quantum size is determined by the
image depth, which can be eight, sixteen, or thirty-two bits.</p>
<table>
<caption>RGB(A) Image Quantums</caption>
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>IndexQuantum</p></td>
<td><p>PseudoColor colormap indices (valid only for image with colormap)</p></td>
</tr>
<tr><td><p>RedQuantum</p></td>
<td><p>Red pixel Quantum</p></td>
</tr>
<tr><td><p>GreenQuantum</p></td>
<td><p>Green pixel Quantum</p></td>
</tr>
<tr><td><p>BlueQuantum</p></td>
<td><p>Blue pixel Quantum</p></td>
</tr>
<tr><td><p>OpacityQuantum</p></td>
<td><p>Opacity (Alpha) Quantum</p></td>
</tr>
</tbody>
</table>
<table>
<caption>CMY(K) Image Quantum</caption>
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>CyanQuantum</p></td>
<td><p>Cyan pixel Quantum</p></td>
</tr>
<tr><td><p>MagentaQuantum</p></td>
<td><p>Magenta pixel Quantum</p></td>
</tr>
<tr><td><p>YellowQuantum</p></td>
<td><p>Yellow pixel Quantum</p></td>
</tr>
<tr><td><p>BlackQuantum</p></td>
<td><p>Black pixel Quantum</p></td>
</tr>
</tbody>
</table>
<table>
<caption>Grayscale Image Quantums</caption>
<colgroup>
<col style="width: 58%" />
<col style="width: 42%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>GrayQuantum</p></td>
<td><p>Gray pixel</p></td>
</tr>
<tr><td><p>GrayOpacityQuantum</p></td>
<td><p>Pixel opacity</p></td>
</tr>
</tbody>
</table>
<table>
<caption>Entire Pixels (Expressed in Byte Order)</caption>
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>RGBQuantum</p></td>
<td><p>RGB pixel (24 or 48 octets)</p></td>
</tr>
<tr><td><p>RGBAQuantum</p></td>
<td><p>RGBA pixel (32 or 64 octets)</p></td>
</tr>
<tr><td><p>CMYKQuantum</p></td>
<td><p>CMYK pixel (32 or 64 octets)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="rectangleinfo">
<h1><a class="toc-backref" href="#id45">RectangleInfo</a></h1>
<p>The RectangleInfo structure is used to represent positioning information
in GraphicsMagick.</p>
<p>The members of the RectangleInfo structure are shown in the following
table:</p>
<table>
<caption>RectangleInfo Structure Members</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 25%" />
<col style="width: 55%" />
</colgroup>
<tbody>
<tr><td><p>Member</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>width</p></td>
<td><p>unsigned long</p></td>
<td><p>Rectangle width</p></td>
</tr>
<tr><td><p>height</p></td>
<td><p>unsigned long</p></td>
<td><p>Rectangle height</p></td>
</tr>
<tr><td><p>x</p></td>
<td><p>long</p></td>
<td><p>Rectangle horizontal offset</p></td>
</tr>
<tr><td><p>y</p></td>
<td><p>long</p></td>
<td><p>Rectangle vertical offset</p></td>
</tr>
</tbody>
</table>
</section>
<section id="registrytype">
<h1><a class="toc-backref" href="#id46">RegistryType</a></h1>
<pre class="literal-block">typedef enum
{
  UndefinedRegistryType,
  ImageRegistryType,
  ImageInfoRegistryType
} RegistryType;</pre>
</section>
<section id="renderingintent">
<h1><a class="toc-backref" href="#id47">RenderingIntent</a></h1>
<p>Rendering intent is a concept defined by ICC Spec ICC.1:1998-09, &quot;File
Format for Color Profiles&quot;. GraphicsMagick uses RenderingIntent in order
to support ICC Color Profiles.</p>
<p>From the specification: &quot;Rendering intent specifies the style of
reproduction to be used during the evaluation of this profile in a
sequence of profiles. It applies specifically to that profile in the
sequence and not to the entire sequence. Typically, the user or
application will set the rendering intent dynamically at runtime or
embedding time.&quot;</p>
<table>
<caption>RenderingIntent</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 83%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedIntent</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>SaturationIntent</p></td>
<td><p>A rendering intent that specifies the saturation of the pixels in the image is
preserved perhaps at the expense of accuracy in hue and lightness.</p></td>
</tr>
<tr><td><p>PerceptualIntent</p></td>
<td><p>A rendering intent that specifies the full gamut of the image is compressed or
expanded to fill the gamut of the destination device. Gray balance is preserved
but colorimetric accuracy might not be preserved.</p></td>
</tr>
<tr><td><p>AbsoluteIntent</p></td>
<td><p>Absolute colorimetric</p></td>
</tr>
<tr><td><p>RelativeIntent</p></td>
<td><p>Relative colorimetric</p></td>
</tr>
</tbody>
</table>
</section>
<section id="resolutiontype">
<h1><a class="toc-backref" href="#id48">ResolutionType</a></h1>
<p>By default, GraphicsMagick defines resolutions in pixels per inch.
ResolutionType provides a means to adjust this.</p>
<table>
<caption>ResolutionType</caption>
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedResolution</p></td>
<td><p>Unset value.</p></td>
</tr>
<tr><td><p>PixelsPerInchResolution</p></td>
<td><p>Density specifications are specified in units of pixels per inch
(english units).</p></td>
</tr>
<tr><td><p>PixelsPerCentimeterResolution</p></td>
<td><p>Density specifications are specified in units of pixels per
centimeter (metric units).</p></td>
</tr>
</tbody>
</table>
</section>
<section id="resourcetype">
<h1><a class="toc-backref" href="#id49">ResourceType</a></h1>
<p>Resource limits constrain the system resources that a GraphicsMagick
process may consume, or that individual decode/encode and/or image
processing operations may consume.  If a resource is expended and
another resource may be substituted (such as RAM memory vs an on-disk
temporary file), then the alternative resource is used until it is
also expended.  When a resource limit is exceeded and there is no more
alternative resource available, then a hard error is reported for the
operation being performed.</p>
<p>Global limits may be applied for the Pixel Cache total disk space
(Gigabytes), the Pixel Cache number of simultaneous open files
(Files), the Pixel Cache total file memory-mapping (Megabytes), the
maximum heap memory allocations (Megabytes), the maximum number of
pixels in a single image (Pixels), the maximum number of worker threads,
the maximum pixel width of an image (Pixels), the maximum pixel height
of an image (Pixels), and the maximum amount of uncompressed file data
which may be read while decoding.</p>
<p>Normally these limits should be set before using GraphicsMagick to
perform other operations.  Environment variables are available which
may also set these properties when GraphicsMagick is initialized.</p>
<table>
<caption>ResourceType</caption>
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedResource</p></td>
<td><p>Undefined value</p></td>
</tr>
<tr><td><p>DiskResource</p></td>
<td><p>Pixel cache total disk space (Gigabytes)</p></td>
</tr>
<tr><td><p>FileResource</p></td>
<td><p>Pixel cache number of open files (Files)</p></td>
</tr>
<tr><td><p>MapResource</p></td>
<td><p>Pixel cache total file memory-mapping (Megabytes)</p></td>
</tr>
<tr><td><p>MemoryResource</p></td>
<td><p>Maximum heap memory (e.g. malloc) allocations (Megabytes)</p></td>
</tr>
<tr><td><p>PixelsResource</p></td>
<td><p>Maximum number of pixels in a single image (Pixels)</p></td>
</tr>
<tr><td><p>ThreadsResource</p></td>
<td><p>Maximum number of worker threads</p></td>
</tr>
<tr><td><p>WidthResource</p></td>
<td><p>Maximum pixel width of an image (Pixels)</p></td>
</tr>
<tr><td><p>HeightResource</p></td>
<td><p>Maximum pixel height of an image (Pixels)</p></td>
</tr>
<tr><td><p>ReadResource</p></td>
<td><p>Maximum amount of uncompressed file data which may be read while
decoding</p></td>
</tr>
</tbody>
</table>
</section>
<section id="segmentinfo">
<h1><a class="toc-backref" href="#id50">SegmentInfo</a></h1>
<pre class="literal-block">typedef struct _SegmentInfo
{
  double
    x1,
    y1,
    x2,
    y2;
} SegmentInfo;</pre>
</section>
<section id="signatureinfo">
<h1><a class="toc-backref" href="#id51">SignatureInfo</a></h1>
<pre class="literal-block">typedef struct _SignatureInfo
{
  unsigned long
    digest[8],
    low_order,
    high_order;

  long
    offset;

  unsigned char
    message[SignatureSize];
} SignatureInfo;</pre>
</section>
<section id="storagetype">
<h1><a class="toc-backref" href="#id52">StorageType</a></h1>
<pre class="literal-block">typedef enum
{
  CharPixel,
  ShortPixel,
  IntegerPixel,
  LongPixel,
  FloatPixel,
  DoublePixel
} StorageType;</pre>
</section>
<section id="streamhandler">
<h1><a class="toc-backref" href="#id53">StreamHandler</a></h1>
<pre class="literal-block">typedef unsigned int
  (*StreamHandler)(const Image *,const void *,const size_t);</pre>
</section>
<section id="stretchtype">
<h1><a class="toc-backref" href="#id54">StretchType</a></h1>
<pre class="literal-block">typedef enum
{
  NormalStretch,
  UltraCondensedStretch,
  ExtraCondensedStretch,
  CondensedStretch,
  SemiCondensedStretch,
  SemiExpandedStretch,
  ExpandedStretch,
  ExtraExpandedStretch,
  UltraExpandedStretch,
  AnyStretch
} StretchType;</pre>
</section>
<section id="styletype">
<h1><a class="toc-backref" href="#id55">StyleType</a></h1>
<pre class="literal-block">typedef enum
{
  NormalStyle,
  ItalicStyle,
  ObliqueStyle,
  AnyStyle
} StyleType;</pre>
</section>
<section id="typemetric">
<h1><a class="toc-backref" href="#id56">TypeMetric</a></h1>
<pre class="literal-block">typedef struct _TypeMetric
{
  PointInfo
    pixels_per_em;

  double
    ascent,
    descent,
    width,
    height,
    max_advance;

  SegmentInfo
    bounds;

  double
    underline_position,
    underline_thickness;
} TypeMetric;</pre>
</section>
<section id="viewinfo">
<h1><a class="toc-backref" href="#id57">ViewInfo</a></h1>
<p>ViewInfo represents a handle to a pixel view, which represents a uniquely
selectable rectangular region of pixels. The only limit on the number of
views is the amount of available memory. Each image contains a collection
of default views (one view per thread) so that the image may be usefully
accessed without needing to explicitly allocate pixel views.</p>
<pre class="literal-block">typedef void *ViewInfo;</pre>
</section>
<section id="virtualpixelmethod">
<h1><a class="toc-backref" href="#id58">VirtualPixelMethod</a></h1>
<p>The VirtualPixelMethod enumeration describes how the pixel cache APIs
fill requested pixel regions which are outside of the image. Returned
pixels <em>must</em> be initialized to some value.  The edge of the image
represents a &quot;disconnect&quot; but convolutions and other filters need
mathematical continuity while computing their results or else the
computed edges of the image would be distorted.</p>
<table>
<caption>VirtualPixelMethod Enumeration Values</caption>
<colgroup>
<col style="width: 36%" />
<col style="width: 64%" />
</colgroup>
<tbody>
<tr><td><p>Enumeration</p></td>
<td><p>Description</p></td>
</tr>
<tr><td><p>UndefinedVirtualPixelMethod</p></td>
<td><p>Value was not specified</p></td>
</tr>
<tr><td><p>ConstantVirtualPixelMethod</p></td>
<td><p>Use the image background color</p></td>
</tr>
<tr><td><p>EdgeVirtualPixelMethod</p></td>
<td><p>Extend the edge pixel toward infinity (default)</p></td>
</tr>
<tr><td><p>MirrorVirtualPixelMethod</p></td>
<td><p>Mirror the image</p></td>
</tr>
<tr><td><p>TileVirtualPixelMethod</p></td>
<td><p>Tile the image</p></td>
</tr>
</tbody>
</table>
</section>
<section id="magickxresourceinfo">
<h1><a class="toc-backref" href="#id59">MagickXResourceInfo</a></h1>
<pre class="literal-block">typedef struct _XResourceInfo
{
  XrmDatabase
    resource_database;

  ImageInfo
    *image_info;

  QuantizeInfo
    *quantize_info;

  unsigned long
    colors;

  unsigned int
    close_server,
    backdrop;

  char
    *background_color,
    *border_color;

  char
    *client_name;

  XColormapType
    colormap;

  unsigned int
    border_width,
    color_recovery,
    confirm_exit,
    delay;

  char
    *display_gamma;

  char
    *font,
    *font_name[MaxNumberFonts],
    *foreground_color;

  unsigned int
    display_warnings,
    gamma_correct;

  char
    *icon_geometry;

  unsigned int
    iconic,
    immutable;

  char
    *image_geometry;

  char
    *map_type,
    *matte_color,
    *name;

  unsigned int
    magnify,
    pause;

  char
    *pen_colors[MaxNumberPens];

  char
    *text_font,
    *title;

  int
    quantum;

  unsigned int
    update,
    use_pixmap,
    use_shared_memory;

  unsigned long
    undo_cache;

  char
    *visual_type,
    *window_group,
    *window_id,
    *write_filename;

  Image
    *copy_image;

  int
    gravity;

  char
    home_directory[MaxTextExtent];
} XResourceInfo;</pre>
</section>
</main>


<hr class="docutils">
<div class="document">
    <p><a href="../Copyright.html">Copyright</a> © GraphicsMagick Group 2002 - 2024<!--SPONSOR_LOGO--></p>
</div>

</main>
</body>
</html>
