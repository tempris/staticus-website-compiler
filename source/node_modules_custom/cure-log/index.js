const module_path = require('path');
const module_fs = require('fs');
const { ANSI } = require('./../cure-ansi');
const ansi = new ANSI();

const LOG_LEVEL = {
  NONE: 0,
  ERROR: 1,
  WARN: 2,
  INFO: 3,
  DETAIL: 4,
  DEBUG: 5,
  ALL: 6
};

const LOG_TAG_LOG = '[📜 Log]';

class Log {
  constructor(logFilePath, logLevelConsole = LOG_LEVEL.DETAIL, logLevelFile = LOG_LEVEL.ALL) {
    this.logFilePath = logFilePath;
    this.isDebugSelf = false;

    // Ensure the log file directory exists
    const logDir = module_path.dirname(logFilePath);
    if (!module_fs.existsSync(logDir)) {
      module_fs.mkdirSync(logDir, { recursive: true });
    }

    // Clear the log file or recreate it
    module_fs.writeFileSync(this.logFilePath, '', 'utf8');

    this.currentLogLevelConsole = logLevelConsole;
    this.currentLogLevelFile = logLevelFile;

    // Define log levels and symbols
    this.logLevels = {
      info:     { symbol: '[ℹ️ Info]',       level: LOG_LEVEL.INFO },
      warn:     { symbol: '[⚠️ Warning]',  level: LOG_LEVEL.WARN },
      error:    { symbol: '[❌ Error]',    level: LOG_LEVEL.ERROR },
      debug:    { symbol: '[🐛 Debug]',    level: LOG_LEVEL.DEBUG },
      detail:   { symbol: '[🔍 Detail]',   level: LOG_LEVEL.DETAIL },
      notice:   { symbol: '[📢 Notice]',   level: LOG_LEVEL.INFO },
      success:  { symbol: '[✅ Success]',  level: LOG_LEVEL.INFO },
      begin:    { symbol: '[🚦 Begin]',    level: LOG_LEVEL.INFO },
      end:      { symbol: '[🏁 End]',      level: LOG_LEVEL.INFO },
      init:     { symbol: '[🚀 Init]',     level: LOG_LEVEL.INFO },
      shutdown: { symbol: '[🛑 Shutdown]', level: LOG_LEVEL.INFO }
    };

    // Define ANSI codes for styling
    this.ansiCodes = (level) => (
      {
        info: ansi.bc.fg.cyan,
        detail: ansi.bc.fg.blue,
        notice: ansi.bc.fg.yellow,
        success: ansi.bc.fg.green,
        warn: ansi.bc.fg.yellow,
        error: ansi.bc.fg.red,
        debug: ansi.bc.fg.green + ansi.style.underline,
        // debug: ansi.bc.fg.green,
        begin: ansi.bc.bg.magenta + ansi.fg.white,
        end: ansi.bc.bg.magenta + ansi.fg.white,
        init: ansi.bc.bg.blue + ansi.fg.white,
        shutdown: ansi.bc.bg.blue + ansi.fg.white
      }[level] || null
    );

    // Define ANSI codes for styling
    this.ansiCodesFollow = (level) => (
      {
        begin: ansi.bc.fg.magenta,
        end: ansi.bc.fg.magenta,
        init: ansi.bc.fg.blue,
        shutdown: ansi.bc.fg.blue
      }[level] || null
    );

    // Determine the correct console method based on the log level
    this.consoleMethod = (level) => (
      {
        info: console.info,
        warn: console.warn,
        error: console.error,
        debug: console.debug
      }[level] || console.log
    );
  }

  ansiRemove(input) {
    // Regex to remove ANSI escape codes
    const ansiRegex = /\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])/g;
    return input.replace(ansiRegex, '');
  }

  getLogFile() {
    return this.logFilePath;
  }

  debugSelf(...args) {
    if (!this.isDebugSelf) {
      return;
    }
    console.log(`${ansi.bc.bg.green + ansi.fg.black}📜🐛 [Log Debug] ${args}${ansi.reset}`);
  }

  isPath(input) {
    if (typeof input !== 'string' || input.trim() === '') {
      return false; // Not a string or empty
    }

    // Normalize to remove query parameters or fragments (e.g., "?v=1.0.0" or "#anchor")
    const cleanInput = input.split(/[?#]/)[0].trim();

    // Check for absolute paths
    if (module_path.isAbsolute(cleanInput)) {
      return true;
    }

    // Check for relative paths (starting with ./ or ../ or directly a file/directory)
    if (cleanInput.startsWith('./') || cleanInput.startsWith('../')) {
      return true;
    }

    // Ensure the structure looks like a path with at least one separator and a valid extension
    const validExtension = cleanInput.match(/\.[a-z0-9]+$/i); // Matches file extensions
    const hasSeparators = cleanInput.includes('/') || cleanInput.includes('\\');

    return hasSeparators && (validExtension || cleanInput.endsWith('/'));
  }

  // Normalize the path to always use forward slashes
  normalizePath(filePath) {
    return filePath.split(module_path.sep).join('/');
  }

  // Helper function to format objects (arrays, JSON, nested data)
  formatArg(arg, indentLevel = 0, tagParent = '', maxDepth = 16) {
    if (indentLevel > maxDepth) {
      return `<[[ANSI_OFF]]Max Depth Reached[[ANSI_ON]]>`;
    }

    const indent = '  '.repeat(indentLevel);

    // console.log(`this.isPath(arg): ${this.isPath(arg)}`);

    if (Array.isArray(arg)) {
      this.debugSelf('arg is array');

      const [firstItem, ...rest] = arg;

      // Check for tagged arrays with formatting instructions
      if (typeof firstItem === 'string' && firstItem.startsWith('[[') && firstItem.endsWith(']]')) {
        const tag = firstItem.slice(2, -2);

        switch (tag) {
          case 'NEWLINES': {
            return rest
              .map((item) => this.formatArg(item, indentLevel, tag, maxDepth))
              .join('\n');
          }

          // case 'LIST': {
          //   return rest
          //     .map((item) => `${indent}> ${this.formatArg(item, indentLevel + 1, tag, maxDepth)}`)
          //     .join('\n');
          // }

          case 'LIST': {
            return rest
              .map((item) => {
                const isNestedList =
                  Array.isArray(item) &&
                  typeof item[0] === 'string' &&
                  item[0].startsWith('[[') &&
                  item[0].endsWith(']]') &&
                  item[0].slice(2, -2) === 'LIST';

                return `${indent}${isNestedList ? '' : '> '}${this.formatArg(item, indentLevel + 1, tag, maxDepth)}`;
              })
              .join('\n');
          }

          case 'NORMAL': {
            return rest
              .map((item, index) =>
                index === rest.length - 1
                  ? `${this.formatArg(item, indentLevel, '', maxDepth)}`
                  : `${this.formatArg(item, indentLevel, '', maxDepth)} `
              )
              .join('');
          }

          default: {
            this.error(LOG_TAG_LOG, 'Unknown tag in next log:', tag);
            // return `Unknown tag: ${tag}`;
          }
        }
      }

      // Standard array formatting
      const len = arg.length;
      return `Array (${len} Entr${len !== 1 ? 'ies' : 'y'}): [\n${arg
        .map((item) => `${indent}  ${this.formatArg(item, indentLevel + 1, 'ARRAY', maxDepth)}`)
        .join(',\n')}\n${indent}]`;
    } else if (typeof arg === 'object' && arg !== null) {
      this.debugSelf('arg is object and not null');

      // Format objects
      const entries = Object.entries(arg)
        .map(
          ([key, value]) =>
            `${indent}  [[ANSI_OFF]]${key}[[ANSI_ON]]: ${this.formatArg(value, indentLevel + 1, 'OBJECT')}`
        )
        .join(',\n');
      const len = Object.keys(arg).length;
      return `Object (${len} Entr${len !== 1 ? 'ies' : 'y'}): {\n${entries}\n${indent}}`;
    } else if (arg === undefined) {
      this.debugSelf('arg is undefined');

      return '`[[ANSI_OFF]]undefined[[ANSI_ON]]`';
    } else if (arg === null) {
      this.debugSelf('arg is null');

      return '`[[ANSI_OFF]]null[[ANSI_ON]]`';
    } else if (typeof arg === 'function') {
      this.debugSelf('arg is function');

      return `[Function: [[ANSI_OFF]]${arg.name || 'anonymous'}[[ANSI_ON]]]`;
    } else if (typeof arg === 'number' || typeof arg === 'boolean') {
      this.debugSelf('arg is number or boolean');

      return `\`[[ANSI_OFF]]${arg}[[ANSI_ON]]\``;
    } else if (this.isPath(arg)) {
      this.debugSelf('arg is path');

      return `\"[[ANSI_OFF]]${this.normalizePath(arg)}[[ANSI_ON]]\"`;
    } else if (typeof arg === 'string' && tagParent !== 'ARRAY' && tagParent !== 'OBJECT') {
      this.debugSelf('arg is string and parent is not array or object');

      return arg;
    } else {
      this.debugSelf('arg is unknown, using default');

      return JSON.stringify(arg).replace(/"(.+)"$/, '"[[ANSI_OFF]]$1[[ANSI_ON]]"');
    }
  }

  setLogLevel(level) {
    if (level in LOG_LEVEL) {
      this.currentLogLevel = level;
    } else {
      throw new Error(`Invalid debug level: ${level}`);
    }
  }

  writeToLogFile(logMessage) {
    module_fs.appendFileSync(this.logFilePath, logMessage.replace(/\[\[ANSI_OFF\]\]/g, '').replace(/\[\[ANSI_ON\]\]/g, '') + '\n', 'utf8');
  }

  prefixTimestamp(...args) {
    const timestamp = new Date().toISOString();
    return `[${timestamp}] ${args}`;
  }

  joinArgs(...args) {
    // const formattedArgs = args
    //   .map(arg => (typeof arg === 'object' ? `${this.formatArg(arg)}` : (typeof arg === 'string' ? arg : this.formatArg(arg))))
    //   .join(' ');

    // Determine join character dynamically based on the previous argument
    return args.reduce((acc, arg, index) => {
      const prevArg = acc[acc.length - 1];
      const joinChar =
        typeof prevArg === 'string' && prevArg.endsWith('\n')
          ? ''
          : ' ';

      const formattedArg = this.formatArg(arg);
      if (acc.length > 0) {
        acc.push(joinChar + formattedArg);
      } else {
        acc.push(formattedArg);
      }
      return acc;
    }, []).join('');
  }

  file(...args) {
    this.writeToLogFile(this.joinArgs(...args));
  }

  console(...args) {
    console.log(this.joinArgs(...args));
  }

  log(level, ...args) {
    const logLevel = this.logLevels[level];
    if (!logLevel) {
      throw new Error(`Invalid log level: ${level}`);
    }

    // Check if the message's debug level is below the current level
    if (logLevel.level > this.currentLogLevelConsole && logLevel.level > this.currentLogLevelFile) {
      return; // Skip logging
    }

    // Handle the first argument if it's a string with a leading \n
    let initialNewline = '';
    if (typeof args[0] === 'string' && args[0].startsWith('\n')) {
      initialNewline = '\n';
      args[0] = args[0].slice(1); // Remove the leading \n
      // Remove trailing spaces on a subsequent split and join
    }

    // const formattedArgs = args
    //   .map(arg => (typeof arg === 'object' ? `${this.formatArg(arg)}` : (typeof arg === 'string' ? arg : this.formatArg(arg))))
    //   .join(' ');

    // Determine join character dynamically based on the previous argument
    const formattedArgs = args.reduce((acc, arg, index) => {
      const prevArg = acc[acc.length - 1];
      const joinChar =
        typeof prevArg === 'string' && prevArg.endsWith('\n')
          ? ''
          : ' ';

      const formattedArg = this.formatArg(arg);
      if (acc.length > 0) {
        acc.push(joinChar + formattedArg);
      } else {
        acc.push(formattedArg);
      }
      return acc;
    }, []).join('');

    let logMessage = this.prefixTimestamp(`${logLevel.symbol} ${formattedArgs}`);

    // Add the initial newline back after adding the timestamp
    logMessage = `${initialNewline}${logMessage}`;

    // Check if the message's debug level is below the current level
    if (!(logLevel.level > this.currentLogLevelFile)) {
      this.writeToLogFile(this.ansiRemove(logMessage));
    }

    // Check if the message's debug level is below the current level
    if (logLevel.level > this.currentLogLevelConsole) {
      return; // Skip logging
    }

    // Split the log message into lines
    const lines = logMessage.split('\n');

    // Check if there are multiple lines and if `ansiCodesFollow` is defined for the level
    if (lines.length > 1 && this.ansiCodesFollow(level)) {
      // Format the first line with the primary ANSI code
      const formattedFirstLine = ansi.format(this.ansiCodes(level), lines[0]);

      // Format subsequent lines with the follow-up ANSI code
      const formattedFollowLines = lines.slice(1).map(line =>
        ansi.format(this.ansiCodesFollow(level), line)
      );

      // Combine all formatted lines
      logMessage = [formattedFirstLine, ...formattedFollowLines].join('\n');
    } else {
      // Format the single-line message or fallback to primary ANSI code
      logMessage = ansi.format(this.ansiCodes(level), logMessage);
    }

    // Print to terminal
    // this.consoleMethod(level)(logMessage);
    this.consoleMethod(level)(logMessage);
  }

  custom(ansiCode, ...args) {
    const timestampedMessage = this.prefixTimestamp('[Custom] ' + this.joinArgs(...args))

    this.writeToLogFile(timestampedMessage);

    // Print styled message to the console
    console.log(ansi.format(ansiCode, timestampedMessage));
  }

  plain(...args) {
    const joinedArgs = this.joinArgs(...args);
    this.writeToLogFile(this.ansiRemove(joinedArgs));
    console.log(joinedArgs);
  }

  bridge(...args) {
    const joinedArgs = this.joinArgs(...args);
    this.writeToLogFile(this.ansiRemove(joinedArgs).trimEnd());
    console.log(joinedArgs.trimEnd());
  }

  info(...args) {
    this.log('info', ...args);
  }

  warn(...args) {
    this.log('warn', ...args);
  }

  error(...args) {
    this.log('error', ...args);
  }

  debug(...args) {
    this.log('debug', ...args);
  }

  detail(...args) {
    this.log('detail', ...args);
  }

  notice(...args) {
    this.log('notice', ...args);
  }

  success(...args) {
    this.log('success', ...args);
  }

  begin(...args) {
    this.log('begin', ...args);
  }

  end(...args) {
    this.log('end', ...args);
  }

  init(...args) {
    this.log('init', ...args);
  }

  shutdown(...args) {
    this.log('shutdown', ...args);
  }

  setDebug(value) {
    this.isDebugSelf = value;
  }

  // Example Usage
  logTest() {
    const logTagTest = '[🧪 Test]';

    this.begin(logTagTest, LOG_TAG_LOG, 'Running...');

    this.begin(logTagTest, LOG_TAG_LOG, 'Simple Test Running...');

    this.info(logTagTest, LOG_TAG_LOG, 'This is an info log.');
    this.warn(logTagTest, LOG_TAG_LOG, 'This is a warning log.');
    this.error(logTagTest, LOG_TAG_LOG, 'This is an error log.');
    this.detail(logTagTest, LOG_TAG_LOG, 'This is a detail log. The following debug log should appear in the log file but not console with default levels.');
    this.debug(logTagTest, LOG_TAG_LOG, 'This is a debug log (should appear in the log file but not console with default levels).');
    this.custom(ansi.bc.bg.yellow + ansi.fg.black + ansi.style.underline + ansi.style.italic, logTagTest, LOG_TAG_LOG, 'This is a custom log.');
    this.shutdown('This is a shutdown log.');

    this.end(logTagTest, LOG_TAG_LOG, 'Simple Test Complete.');
    this.begin(logTagTest, LOG_TAG_LOG, 'Data Type Test Running...');

    const dataSamples = {
      string: 'This is a string.',
      number: 42,
      boolean: true,
      array: ['Array item 1', 'Array item 2'],
      nestedArray: [['Nested Array 1'], ['Nested Array 2']],
      object: { key1: 'value1', key2: 'value2' },
      nestedObject: { outerKey: { innerKey: 'innerValue' } },
      null: null,
      undefined: undefined,
      function: function exampleFunction() { return 'Hello'; },
      path: './relative/path/to/file.txt'
    };

    for (const [type, value] of Object.entries(dataSamples)) {
      this.info(logTagTest, LOG_TAG_LOG, `Testing type \'${type}\':`, value);
    }

    this.end(logTagTest, LOG_TAG_LOG, 'Data Type Test Complete.');
    this.begin(logTagTest, LOG_TAG_LOG, 'Mixed Variable Type Test Running...');

    this.info('Mixed:', 123, undefined, null, 'Mixed End.');

    this.info(
      'Extreme Mixed:',
      ['input1.txt', 'input2.txt'],
      { stage: 'initialization', config: { retry: true, timeout: '30s' } },
      123,
      null,
      ['nestedArray', { key: 'value' }],
      undefined,
      'Intermediate log message',
      { errors: null, warnings: ['Low memory', 'Disk space low'] },
      [42, 'randomValue', { inner: 'object' }],
      'Extreme Mixed End.'
    );

    this.end(logTagTest, LOG_TAG_LOG, 'Mixed Variable Type Test Complete.');
    this.begin(logTagTest, LOG_TAG_LOG, 'Array Tag Test Running...');

    this.info([
      '[[NEWLINES]]',
      'Example:',
      'This string is on a new line.',
      [
        '[[LIST]]',
        'This string is in a list.',
        [
          'This string is in an array in a list.',
          123
        ],
        ['[[NORMAL]]', 'This string is in a list with a variable after it:', 123],
        [
          '[[LIST]]',
          'This string is in a list in a list.',
          123
        ],
        'This string is also in a list.'
      ]
    ]);

    this.end(logTagTest, LOG_TAG_LOG, 'Array Tag Test Complete.');
    this.end(logTagTest, LOG_TAG_LOG, 'Complete.');
  }
}

module.exports = { Log };
