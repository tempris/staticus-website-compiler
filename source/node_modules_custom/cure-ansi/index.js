class ANSI {
  constructor() {
    // process.env.NO_COLOR = 1;
    this.noColor = process.env.NO_COLOR !== undefined; // Check if NO_COLOR is set
    this.debug = false;

    this.reset = "\x1b[0m";

    this.style = {
      bold: "\x1b[1m",
      dim: "\x1b[2m",
      italic: "\x1b[3m",
      underline: "\x1b[4m",
      blink: "\x1b[5m",
      reverse: "\x1b[7m",
      hidden: "\x1b[8m",
      strikethrough: "\x1b[9m",
      doubleUnderline: "\x1b[21m",
      framed: "\x1b[51m",
      encircled: "\x1b[52m",
      overlined: "\x1b[53m",
      resetBoldDim: "\x1b[22m",
      resetUnderline: "\x1b[24m",
      resetBlink: "\x1b[25m",
      resetReverse: "\x1b[27m",
      resetHidden: "\x1b[28m",
      resetStrikethrough: "\x1b[29m",
      resetOverlined: "\x1b[55m",
    };

    this.fg = {
      reset: "\x1b[39m",
      black: "\x1b[30m",
      red: "\x1b[31m",
      green: "\x1b[32m",
      yellow: "\x1b[33m",
      blue: "\x1b[34m",
      magenta: "\x1b[35m",
      cyan: "\x1b[36m",
      white: "\x1b[37m",
      bright: {
        black: "\x1b[90m",
        red: "\x1b[91m",
        green: "\x1b[92m",
        yellow: "\x1b[93m",
        blue: "\x1b[94m",
        magenta: "\x1b[95m",
        cyan: "\x1b[96m",
        white: "\x1b[97m",
      },
    };

    this.bg = {
      reset: "\x1b[49m",
      black: "\x1b[40m",
      red: "\x1b[41m",
      green: "\x1b[42m",
      yellow: "\x1b[43m",
      blue: "\x1b[44m",
      magenta: "\x1b[45m",
      cyan: "\x1b[46m",
      white: "\x1b[47m",
      bright: {
        black: "\x1b[100m",
        red: "\x1b[101m",
        green: "\x1b[102m",
        yellow: "\x1b[103m",
        blue: "\x1b[104m",
        magenta: "\x1b[105m",
        cyan: "\x1b[106m",
        white: "\x1b[107m",
      },
    };

    // High Contrast Colors
    this.hc = {
      // Foreground Colors
      fg: {
        black: this.fg.bright.black,   // Bright Black (Gray) text
        red: this.fg.bright.red,     // Bright Red text
        green: this.fg.bright.green,   // Bright Green text
        yellow: this.fg.bright.yellow,  // Bright Yellow text
        blue: this.fg.bright.blue,    // Bright Blue text
        magenta: this.fg.bright.magenta, // Bright Magenta text
        cyan: this.fg.bright.cyan,    // Bright Cyan text
        white: this.fg.bright.white,   // Bright White text
      },

      // Background Colors
      bg: {
        black: this.bg.black,      // Black background
        red: this.bg.red,        // Red background
        green: this.bg.green,      // Green background
        yellow: this.bg.yellow,     // Yellow background
        blue: this.bg.blue,       // Blue background
        magenta: this.bg.magenta,    // Magenta background
        cyan: this.bg.cyan,       // Cyan background
        white: this.bg.white,      // White background
      },
    };

    // Balanced Contrast Colors
    this.bc = {
      // Foreground Colors
      fg: {
        black: this.fg.bright.black,
        red: this.fg.bright.red,
        green: this.fg.bright.green,
        yellow: this.fg.yellow,
        blue: this.fg.bright.blue,
        magenta: this.fg.bright.magenta,
        cyan: this.fg.bright.cyan,
        white: this.fg.bright.white,
      },

      // Background Colors
      bg: {
        black: this.bg.black,
        red: this.bg.red,
        green: this.bg.green,
        yellow: this.bg.yellow,
        blue: this.bg.blue,
        magenta: this.bg.magenta,
        cyan: this.bg.cyan,
        white: this.bg.white,
      },
    };

    this.cursor = {
      up: (n = 1) => `\x1b[${n}A`,
      down: (n = 1) => `\x1b[${n}B`,
      right: (n = 1) => `\x1b[${n}C`,
      left: (n = 1) => `\x1b[${n}D`,
      moveTo: (row, col) => `\x1b[${row};${col}H`,
      show: "\x1b[?25h",
      hide: "\x1b[?25l",
    };

    this.screen = {
      clear: "\x1b[2J",
      clearFromCursorToEnd: "\x1b[0J",
      clearFromCursorToStart: "\x1b[1J",
      clearLine: "\x1b[2K",
      clearLineToEnd: "\x1b[0K",
      clearLineToStart: "\x1b[1K",
    };

    this.color256 = {
      fg: (n) => `\x1b[38;5;${n}m`,
      bg: (n) => `\x1b[48;5;${n}m`,
    };

    this.colorRGB = {
      fg: (r, g, b) => `\x1b[38;2;${r};${g};${b}m`,
      bg: (r, g, b) => `\x1b[48;2;${r};${g};${b}m`,
    };

    // Attach the test namespace
    this.test = {
      standard: this.testStandard.bind(this),
      color256: this.testColor256.bind(this),
      screen: this.testScreen.bind(this),
      cursor: this.testCursor.bind(this),
      reveal: this.testReveal.bind(this),
      clean: this.testClean.bind(this),
      all: this.testAll.bind(this), // Optional method to run all tests
    };
  }

  setDebug(value) {
    this.debug = value;
  }

  /**
   * Returns "white" or "black" based on a single luminance threshold.
   * @param {string|number} input - The ANSI color code (0â€“255) or escape sequence (e.g., "\x1b[31m").
   * @param {number} [threshold=0.5] - The luminance threshold (default is 0.5).
   * @returns {string} "white" or "black".
   */
  getContrastName(input, threshold = 0.2) {
    // Parse ANSI escape sequences (e.g., "\x1b[31m")
    function parseEscapeSequence(escapeSequence) {
      const match = /\x1b\[(\d+)m/.exec(escapeSequence);
      if (match) {
        const colorCode = parseInt(match[1], 10);
        if (colorCode >= 30 && colorCode <= 37) {
          // Map basic foreground colors
          return colorCode - 30;
        } else if (colorCode >= 90 && colorCode <= 97) {
          // Map bright foreground colors
          return colorCode - 90 + 8;
        }
      }
      throw new Error("Invalid ANSI escape sequence");
    }
  
    // Convert ANSI color code to RGB
    function ansiToRgb(ansi) {
      if (ansi < 16) {
        // Standard colors
        const baseColors = [
          [0, 0, 0], [128, 0, 0], [0, 128, 0], [128, 128, 0],
          [0, 0, 128], [128, 0, 128], [0, 128, 128], [192, 192, 192],
          [128, 128, 128], [255, 0, 0], [0, 255, 0], [255, 255, 0],
          [0, 0, 255], [255, 0, 255], [0, 255, 255], [255, 255, 255],
        ];
        return baseColors[ansi];
      } else if (ansi >= 16 && ansi < 232) {
        // 6x6x6 color cube
        const base = ansi - 16;
        return [
          Math.floor(base / 36) * 51,
          Math.floor((base % 36) / 6) * 51,
          (base % 6) * 51,
        ];
      } else if (ansi >= 232 && ansi < 256) {
        // Grayscale colors
        const gray = Math.floor((ansi - 232) * 10 + 8);
        return [gray, gray, gray];
      }
      throw new Error("Invalid ANSI color code");
    }
  
    // Calculate relative luminance of a color (perceived brightness)
    function getLuminance(rgb) {
      const [r, g, b] = rgb.map(channel => {
        const scaled = channel / 255;
        return scaled <= 0.03928 ? scaled / 12.92 : Math.pow((scaled + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }
  
    // Determine the ANSI code
    let ansiCode;
    if (typeof input === "string" && input.startsWith("\x1b[")) {
      ansiCode = parseEscapeSequence(input);
    } else if (typeof input === "number") {
      ansiCode = input;
    } else {
      throw new Error("Invalid input type");
    }
  
    const rgb = ansiToRgb(ansiCode);
    const luminance = getLuminance(rgb);

    // Return contrast color based on threshold
    return luminance > threshold ? "black" : "white";
  }

  getContrastFg(colorIndex) {
    return this.getContrastName(colorIndex) === "white" ? this.fg.white : this.fg.black;
  }

  getContrastBg(colorIndex) {
    return this.getContrastName(colorIndex) === "white" ? this.bg.white : this.bg.black;
  }

  reveal(text) {
    const realAnsiRegex = /\x1b\[[0-9;]*m/g; // Matches real ANSI codes

    // Process real ANSI codes
    return text.replace(realAnsiRegex, (match) => {
      return `${match}${match.replace(/\x1b/g, '\\x1b')}`; // Add plain text representation alongside the real code
    });
  }

  // Function to categorize ANSI code
  categorizeCode(code, activeCodes) {
    if (code === this.reset) {
      // Reset all active codes
      activeCodes = {
        foreground: '',
        background: '',
        formatting: [],
      };
    } else if (/^\x1b\[(3[0-7]|9[0-7])m$/.test(code)) {
      // Foreground colors (3x for normal, 9x for bright)
      activeCodes.foreground = code;
    } else if (/^\x1b\[(4[0-7]|10[0-7])m$/.test(code)) {
      // Background colors (4x for normal, 10x for bright)
      activeCodes.background = code;
    } else if (/^\x1b\[(1|2|3|4|5|7|8|9)m$/.test(code)) {
      // Text styles (bold, dim, italic, etc.)
      const style = code; // Keep the full style code
      if (!activeCodes.formatting.includes(style)) {
        activeCodes.formatting.push(style);
      }
    }
  }

  clean(inputString) {
    // Regex to match ANSI escape codes
    const ansiRegex = /\x1b\[[0-9;]*[a-zA-Z]/g;

    // Object to track active ANSI codes
    let activeCodes = {
      foreground: '',
      background: '',
      formatting: [],
    };

    // Split input string into lines
    const lines = inputString.split('\n');

    // Processed lines array
    const processedLines = [];

    // Iterate through each line
    for (const line of lines) {
      if (this.debug) {
        console.log(`\n+ line:\n${this.reveal(line)}${this.reset}`);
      }

      let leadingPart = '';
      let restOfLine = line;

      // Match ANSI codes and whitespace at the beginning of the line
      const leadingMatch = line.match(/^((?:\x1b\[[0-9;]*[a-zA-Z])*\s*)/);

      if (leadingMatch) {
        leadingPart = leadingMatch[0];
        restOfLine = line.slice(leadingPart.length).trim();
      }

      // Extract ANSI codes and spaces from the leading part
      const leadingAnsiCodes = leadingPart.match(ansiRegex) || [];
      const leadingSpaces = leadingPart.replace(ansiRegex, '');

      // Process ANSI codes in the leading part to update active codes
      for (const code of leadingAnsiCodes) {
        this.categorizeCode(code, activeCodes);
      }

      // Reconstruct leading whitespace
      const activeCodesString = [
        activeCodes.foreground,
        activeCodes.background,
        ...activeCodes.formatting
      ].filter(Boolean).join('');
      const reconstructedLeadingWhitespace = `${this.reset}${leadingSpaces}${activeCodesString}`;

      // Process the remaining part of the line for additional ANSI codes
      const restAnsiCodes = restOfLine.match(ansiRegex) || [];
      for (const code of restAnsiCodes) {
        this.categorizeCode(code, activeCodes);
      }

      // Reconstruct the processed line
      const processedLine = `${reconstructedLeadingWhitespace}${restOfLine}${this.reset}${this.fg.reset}${this.bg.reset}`;

      if (this.debug) {
        console.log(`+ processedLine:\n${this.reveal(processedLine)}${this.reset}`);
      }

      processedLines.push(processedLine);
    }

    // Recombine processed lines into a single string
    return processedLines.join('\n');
  }

  format(code, ...messages) {
    const ansiCode = this.noColor ? '' : (code || this.reset); // Disable ANSI if NO_COLOR is set
    const resetCode = this.noColor ? '' : this.reset; // Disable reset if NO_COLOR is set
    const text = messages.join(" "); // Concatenate all arguments into a single string
    return this.clean(`${ansiCode}${text}${resetCode}`
      .replace(/\[\[ANSI_ON\]\]/g, ansiCode)
      .replace(/\[\[ANSI_OFF\]\]/g, resetCode));
  }

  testStandard() {
    console.log(`${this.reset}=== Testing ANSI Codes ===`);

    // Test Reset
    console.log(`${this.reset}[Reset] This text should be in default style.`);

    // Test Styles
    console.log(`${this.style.bold}[Bold] This text is bold.${this.reset}`);
    console.log(`${this.style.dim}[Dim] This text is dimmed.${this.reset}`);
    console.log(`${this.style.italic}[Italic] This text is italicized.${this.reset}`);
    console.log(`${this.style.underline}[Underline] This text is underlined.${this.reset}`);
    console.log(`${this.style.blink}[Blink] This text blinks (may not be supported).${this.reset}`);
    console.log(`${this.style.reverse}[Reverse] This text has reversed colors.${this.reset}`);
    console.log('[Hidden] Following line is hidden style:');
    console.log(`${this.style.hidden}[Hidden] This text is hidden.${this.reset}`);
    console.log(`${this.style.strikethrough}[Strikethrough] This text is struck through.${this.reset}`);
    console.log(`${this.style.doubleUnderline}[Double Underline] This text is double underlined.${this.reset}`);
    console.log(`${this.style.framed}[Framed] This text is framed (if supported).${this.reset}`);
    console.log(`${this.style.encircled}[Encircled] This text is encircled (if supported).${this.reset}`);
    console.log(`${this.style.overlined}[Overlined] This text is overlined.${this.reset}`);

    // Test Foreground Colors
    console.log("\n=== Foreground Colors ===");
    for (const [color, code] of Object.entries(this.fg)) {
      if (typeof code === 'object') continue; // Skip nested objects (e.g., "bright")
      console.log(`${code}[${color}] This is ${color} text.${this.fg.reset}`);
    }

    // Test Bright Foreground Colors
    console.log("\n=== Bright Foreground Colors ===");
    for (const [color, code] of Object.entries(this.fg.bright)) {
      console.log(`${code}[Bright ${color}] This is bright ${color} text.${this.fg.reset}`);
    }

    // Test Background Colors
    console.log("\n=== Background Colors ===");
    for (const [color, code] of Object.entries(this.bg)) {
      if (typeof code === 'object') continue; // Skip nested objects (e.g., "bright")
      console.log(`${code}[${color}] This is text with a ${color} background.${this.bg.reset}`);
    }

    // Test Bright Background Colors
    console.log("\n=== Bright Background Colors ===");
    for (const [color, code] of Object.entries(this.bg.bright)) {
      console.log(`${code}[Bright ${color}] This is text with a bright ${color} background.${this.bg.reset}`);
    }
  }

  testColor256() {
    // Test 256-Color Mode
    console.log("\n=== 256-Color Foreground ===");

    const rowLenStandard = 8;
    const rowLen216StepRGB = 6;
    const rowLenGrayscale = 12;
    const rowCountStandard = 2;
    const rowCount216StepRGB = 6 * 6;
    // const rowCountGrayscale = 2;
    const indexCountStandard = rowLenStandard * rowCountStandard;
    const indexCount216StepRGB = rowLen216StepRGB * rowCount216StepRGB;
    // const indexCountGrayscale = rowLenGrayscale * rowCountGrayscale;
    // const indexStartStandard = 0;
    const indexStart216StepRGB = indexCountStandard;
    const indexStartGrayscale = indexCountStandard + indexCount216StepRGB;

    const getRowLen = (index) => {
      if (index < indexStart216StepRGB) {
        return rowLenStandard; // Standard colors
      } else if (index < indexStartGrayscale) {
        return rowLen216StepRGB; // 216 RGB colors
      } else {
        return rowLenGrayscale; // Grayscale
      }
    };

    // Display 256-color foreground in 2D
    for (let i = 0; i < 256; i += getRowLen(i)) {
      let row = "";
      for (let j = 0; j < getRowLen(i); j++) {
        const colorIndex = i + j;
        if (colorIndex >= 256) break; // Ensure we don't exceed the 256-color range
        row += `${this.getContrastBg(colorIndex)}${this.color256.fg(colorIndex)} ${colorIndex.toString().padStart(3, " ")} `;
      }
      console.log(row + this.reset);
    }

    console.log("\n=== 256-Color Background ===");

    // Display 256-color background in 2D
    for (let i = 0; i < 256; i += getRowLen(i)) {
      let row = "";
      for (let j = 0; j < getRowLen(i); j++) {
        const colorIndex = i + j;
        row += `${this.getContrastFg(colorIndex)}${this.color256.bg(colorIndex)} ${colorIndex.toString().padStart(3, " ")} `;
      }
      console.log(row + this.reset);
    }

    // console.log("\n=== 256-Color Background Pixel Style ===");

    // // Display 256-color background in 2D
    // for (let i = 0; i < 256; i += getRowLen(i)) {
    //   let row = "";
    //   for (let j = 0; j < getRowLen(i); j++) {
    //     const colorIndex = i + j;
    //     row += `${this.color256.bg(colorIndex)}  `;
    //   }
    //   console.log(row + this.reset);
    // }

    console.log("\n=== 256-Color Gradient ===");
    console.log(`\nCredit: F. SchrÃ¶der (${this.fg.cyan + this.style.underline}https://www.hackitu.de/termcolor256/${this.reset})`);

    // Define a manual 2D grid of ANSI color indexes
    const colorGrids = [
      {
        name: 'Layer 1 (Outermost)',
        grid: [
          [16, 52,  88, 124, 160, 196, 203, 210, 217, 224, 231],
          [16, 52,  88, 124, 160, 202, 209, 216, 223, 230, 231],
          [16, 52,  88, 124, 166, 208, 215, 222, 229, 230, 231],
          [16, 52,  88, 130, 172, 214, 221, 228, 229, 230, 231],
          [16, 52,  94, 136, 178, 220, 227, 228, 229, 230, 231],
          [16, 58, 100, 142, 184, 226, 227, 228, 229, 230, 231],
          [16, 22,  64, 106, 148, 190, 227, 228, 229, 230, 231],
          [16, 22,  28,  70, 112, 154, 191, 228, 229, 230, 231],
          [16, 22,  28,  34,  76, 118, 155, 192, 229, 230, 231],
          [16, 22,  28,  34,  40,  82, 119, 156, 193, 230, 231],
          [16, 22,  28,  34,  40,  46,  83, 120, 157, 194, 231],
          [16, 22,  28,  34,  40,  47,  84, 121, 158, 195, 231],
          [16, 22,  28,  34,  41,  48,  85, 122, 159, 195, 231],
          [16, 22,  28,  35,  42,  49,  86, 123, 159, 195, 231],
          [16, 22,  29,  36,  43,  50,  87, 123, 159, 195, 231],
          [16, 23,  30,  37,  44,  51,  87, 123, 159, 195, 231],
          [16, 17,  24,  31,  38,  45,  87, 123, 159, 195, 231],
          [16, 17,  18,  25,  32,  39,  81, 123, 159, 195, 231],
          [16, 17,  18,  19,  26,  33,  75, 117, 159, 195, 231],
          [16, 17,  18,  19,  20,  27,  69, 111, 153, 195, 231],
          [16, 17,  18,  19,  20,  21,  63, 105, 147, 189, 231],
          [16, 17,  18,  19,  20,  57,  99, 141, 183, 225, 231],
          [16, 17,  18,  19,  56,  93, 135, 177, 219, 225, 231],
          [16, 17,  18,  55,  92, 129, 171, 213, 219, 225, 231],
          [16, 17,  54,  91, 128, 165, 207, 213, 219, 225, 231],
          [16, 53,  90, 127, 164, 201, 207, 213, 219, 225, 231],
          [16, 52,  89, 126, 163, 200, 207, 213, 219, 225, 231],
          [16, 52,  88, 125, 162, 199, 206, 213, 219, 225, 231],
          [16, 52,  88, 124, 161, 198, 205, 212, 219, 225, 231],
          [16, 52,  88, 124, 160, 197, 204, 211, 218, 225, 231]
        ]
      },
      {
        name: 'Layer 2',
        grid: [
          [59,  95, 131, 167, 174, 181, 188],
          [59,  95, 131, 173, 180, 187, 188],
          [59,  95, 137, 179, 186, 187, 188],
          [59, 101, 143, 185, 186, 187, 188],
          [59,  65, 107, 149, 186, 187, 188],
          [59,  65,  71, 113, 150, 187, 188],
          [59,  65,  71,  77, 114, 151, 188],
          [59,  65,  71,  78, 115, 152, 188],
          [59,  65,  72,  79, 116, 152, 188],
          [59,  66,  73,  80, 116, 152, 188],
          [59,  60,  67,  74, 116, 152, 188],
          [59,  60,  61,  68, 110, 152, 188],
          [59,  60,  61,  62, 104, 146, 188],
          [59,  60,  61,  98, 140, 182, 188],
          [59,  60,  97, 134, 176, 182, 188],
          [59,  96, 133, 170, 176, 182, 188],
          [59,  95, 132, 169, 176, 182, 188],
          [59,  95, 131, 168, 175, 182, 188]
        ]
      },
      {
        name: 'Layer 3 (Innermost)',
        grid: [
          [102, 138, 144, 108, 109, 103, 139, 145]
        ]
      },
    ];

    // Iterate through the grids
    colorGrids.forEach(({ name, grid }, gridIndex) => {
      // Display the grid name or assign a default name
      // const gridName = name || `Grid ${gridIndex + 1}`;
      // console.log(`\n${this.format(this.bold, gridName)}:`);
      if (name) {
        console.log(`\n${this.format(this.bold, name)}:`);
      } else {
        console.log('');
      }

      // Iterate through the rows in the grid
      if (Array.isArray(grid) && grid.length > 0) {
        grid.forEach((row, rowIndex) => {
          if (Array.isArray(row)) {
            let rowDisplay = "";
            row.forEach((colorIndex) => {
              if (Number.isInteger(colorIndex) && colorIndex >= 0 && colorIndex <= 255) {
                rowDisplay += `${this.getContrastFg(colorIndex)}${this.color256.bg(colorIndex)} ${colorIndex.toString().padStart(3, ' ')} `;
              } else {
                rowDisplay += `${this.format(this.bc.red, "ERR")} ??? `;
              }
            });

            var line = rowDisplay + this.reset;

            console.log(line);
          } else {
            console.log(`Row ${rowIndex + 1} is not a valid array`);
          }
        });
      } else {
        console.log(`Grid "${gridName}" is empty or invalid.`);
      }
    });
  }

  testScreen() {
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    async function screenDemo() {
      console.log(`${this.reset}=== Testing Screen Controls ===`);

      // Clear the screen
      console.log("\nClearing the entire screen...");
      console.log("Waiting for 3 seconds before clearing the screen...");
      await sleep(3000);
      console.log(this.screen.clear);

      // Clear from cursor to end
      console.log("\nFilling the screen, then clearing from cursor to end...");
      console.log("Waiting for 3 seconds before action...");
      await sleep(3000);
      for (let i = 0; i < 10; i++) {
        console.log(`Line ${i + 1}: Filled with text`);
      }
      process.stdout.write(this.cursor.moveTo(5, 5)); // Move cursor to row 5, column 5
      console.log(`${this.screen.clearFromCursorToEnd}Cleared from cursor to the end of the screen.`);

      // Clear from cursor to start
      console.log("\nClearing from cursor to start...");
      console.log("Waiting for 3 seconds before action...");
      await sleep(3000);
      process.stdout.write(this.cursor.moveTo(7, 20)); // Move cursor to row 7, column 20
      console.log(`${this.screen.clearFromCursorToStart}Cleared from cursor to the start of the screen.`);

      // Clear line
      console.log("\nClearing an entire line...");
      console.log("Waiting for 3 seconds before action...");
      await sleep(3000);
      process.stdout.write(this.cursor.moveTo(9, 0)); // Move cursor to row 9
      console.log(`This line will be cleared shortly!${this.screen.clearLine}`);

      // Clear line from cursor to end
      console.log("\nClearing from cursor to the end of the line...");
      console.log("Waiting for 3 seconds before action...");
      await sleep(3000);
      process.stdout.write(this.cursor.moveTo(10, 10)); // Move cursor to row 10, column 10
      console.log(`Partially cleared line${this.screen.clearLineToEnd}`);

      // Clear line from cursor to start
      console.log("\nClearing from cursor to the start of the line...");
      console.log("Waiting for 3 seconds before action...");
      await sleep(3000);
      process.stdout.write(this.cursor.moveTo(11, 30)); // Move cursor to row 11, column 30
      console.log(`${this.screen.clearLineToStart}Remaining part of the line cleared.`);

      // Cursor and screen movement demo
      console.log("\nPerforming a cursor and screen movement demo...");
      console.log("Waiting for 3 seconds before action...");
      await sleep(3000);
      console.log(this.screen.clear); // Clear the screen
      for (let i = 1; i <= 5; i++) {
        process.stdout.write(this.cursor.moveTo(i, i * 5));
        console.log(`Row ${i}, Column ${i * 5}`);
        await sleep(500);
      }

      // Restore the cursor position
      console.log("\nTesting save and restore cursor position...");
      console.log("Waiting for 3 seconds before action...");
      await sleep(3000);
      process.stdout.write(this.cursor.moveTo(15, 10));
      console.log("Saved cursor position here!");
      process.stdout.write(this.cursor.save);
      await sleep(3000);

      process.stdout.write(this.cursor.moveTo(20, 20));
      console.log("Moved cursor to a different position!");
      await sleep(3000);

      process.stdout.write(this.cursor.restore);
      console.log("Restored to the saved cursor position.");

      console.log("\n=== End of Screen Controls Demo ===");
    }

    screenDemo();
  }

  testCursor() {
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    async function cursorDemo() {
      console.log(`${this.reset}=== Testing Cursor Controls ===`);

      // Move cursor up
      console.log("\nMoving the cursor up...");
      console.log("Waiting for 3 seconds before moving the cursor...");
      await sleep(3000);
      process.stdout.write("This is the original position.\n".repeat(5)); // Add some lines
      process.stdout.write(this.cursor.up(3)); // Move cursor up 3 lines
      console.log("Cursor moved up 3 lines!");

      // Move cursor down
      console.log("\nMoving the cursor down...");
      console.log("Waiting for 3 seconds before moving the cursor...");
      await sleep(3000);
      process.stdout.write(this.cursor.down(2)); // Move cursor down 2 lines
      console.log("Cursor moved down 2 lines!");

      // Move cursor right
      console.log("\nMoving the cursor to the right...");
      console.log("Waiting for 3 seconds before moving the cursor...");
      await sleep(3000);
      process.stdout.write(this.cursor.right(10)); // Move cursor 10 columns to the right
      console.log("Cursor moved 10 columns to the right!");

      // Move cursor left
      console.log("\nMoving the cursor to the left...");
      console.log("Waiting for 3 seconds before moving the cursor...");
      await sleep(3000);
      process.stdout.write(this.cursor.left(5)); // Move cursor 5 columns to the left
      console.log("Cursor moved 5 columns to the left!");

      // Move cursor to specific position
      console.log("\nMoving the cursor to a specific position (row 10, column 20)...");
      console.log("Waiting for 3 seconds before moving the cursor...");
      await sleep(3000);
      process.stdout.write(this.cursor.moveTo(10, 20)); // Move cursor to row 10, column 20
      console.log("Cursor moved to row 10, column 20!");

      // Save and restore cursor position
      console.log("\nTesting save and restore cursor position...");
      console.log("Waiting for 3 seconds before saving the cursor position...");
      await sleep(3000);
      process.stdout.write(this.cursor.save); // Save the current cursor position
      console.log("Cursor position saved!");
      console.log("Waiting for 3 seconds before moving the cursor...");
      await sleep(3000);
      process.stdout.write(this.cursor.moveTo(15, 5)); // Move cursor to a different position
      console.log("Cursor moved to row 15, column 5!");
      console.log("Waiting for 3 seconds before restoring the cursor...");
      await sleep(3000);
      process.stdout.write(this.cursor.restore); // Restore the saved cursor position
      console.log("Cursor restored to the saved position!");

      // Hide and show cursor
      console.log("\nHiding the cursor...");
      console.log("Waiting for 3 seconds before hiding the cursor...");
      await sleep(3000);
      process.stdout.write(this.cursor.hide); // Hide the cursor
      console.log("Cursor is now hidden!");
      console.log("Waiting for 3 seconds before showing the cursor again...");
      await sleep(3000);
      process.stdout.write(this.cursor.show); // Show the cursor
      console.log("Cursor is now visible again!");

      console.log("\n=== End of Cursor Controls Demo ===");
    }

    cursorDemo();
  }

  // Example usage
  testReveal() {
    const testString = `${this.fg.red}${this.style.underline}This is red underlined text\n    ${this.fg.green}${this.style.underline}This is green underlined text\n        This is green underlined text again plus ${this.fg.red}This is red underlined text${this.reset}        \nNo ANSI codes here`;
    console.log(`++ testString:\n${testString}`);
    console.log(`++ ANSI.reveal(testString):\n${this.reveal(testString)}`);
  }

  // Example usage
  testClean() {
    const testString = `${this.fg.red}${this.style.underline}This is red underlined text\n    ${this.fg.green}${this.style.underline}This is green underlined text\n        This is green underlined text again plus ${this.fg.red}This is red underlined text${this.reset}        \nNo ANSI codes here`;
    console.log(`++ testString:\n${testString}`);
    console.log(`++ [debug] ANSI.reveal(testString):\n${this.reveal(testString)}`);
    console.log(`++ ANSI.clean(testString):\n${this.clean(testString)}`);
  }

  testAll() {
    this.test();
    this.testColor256();
    this.testScreen();
    this.testCursor();
    this.testReveal();
    this.testClean();
  }
}

module.exports = { ANSI };
