const sharp = require('sharp');
const fs = require('fs');
const path = require('path');
const pngToIco = require('png-to-ico');

// function calculateBackgroundScale(blurAmount, outputSize) {
//   if (blurAmount <= 0) return 1.0; // No scaling needed

//   const spreadFactor = 2.0; // Approximate pixel spread per unit of blur
//   const minSize = Math.min(outputSize.width, outputSize.height); // Normalize scale based on smaller dimension

//   return 1 + (blurAmount * spreadFactor) / minSize; // Scale factor based on blur spread
// }

async function createCompositeImage(foreground, background, outputSize, fgAlign = "center", bgAlign = "center") {
  function parseAlignment(value) {
    if (typeof value === "string") {
      switch (value.toLowerCase()) {
        case "left": return 0;
        case "center": return 50;
        case "right": return 100;
        case "top": return 0;
        case "bottom": return 100;
        default: return 50;
      }
    }
    return Math.min(100, Math.max(0, value));
  }

  const fgAlignX = parseAlignment(fgAlign.x ?? fgAlign);
  const fgAlignY = parseAlignment(fgAlign.y ?? fgAlign);
  const bgAlignX = parseAlignment(bgAlign.x ?? bgAlign);
  const bgAlignY = parseAlignment(bgAlign.y ?? bgAlign);

  const fgMetadata = await foreground.metadata();
  const bgMetadata = await background.metadata();

  // Determine the scale for the background image
  const scaleX = outputSize.width / bgMetadata.width;
  const scaleY = outputSize.height / bgMetadata.height;
  const scale = Math.max(scaleX, scaleY); // Use the smallest scale that still covers the entire area

  const newBgWidth = Math.ceil(bgMetadata.width * scale);
  const newBgHeight = Math.ceil(bgMetadata.height * scale);

  const resizedBg = await background
    .resize({
      width: newBgWidth,
      height: newBgHeight,
      fit: "fill",
    })
    .toBuffer();

  // Compute background cropping after resizing
  const bgLeft = Math.round((newBgWidth - outputSize.width) * (bgAlignX / 100));
  const bgTop = Math.round((newBgHeight - outputSize.height) * (bgAlignY / 100));

  const croppedBg = await sharp(resizedBg)
    .extract({
      left: Math.max(0, bgLeft),
      top: Math.max(0, bgTop),
      width: outputSize.width,
      height: outputSize.height,
    })
    .toBuffer();

  // Resize foreground while maintaining aspect ratio
  const fgAspectRatio = fgMetadata.width / fgMetadata.height;
  const targetAspectRatio = outputSize.width / outputSize.height;

  let fgWidth, fgHeight;
  if (fgAspectRatio > targetAspectRatio) {
    fgWidth = outputSize.width;
    fgHeight = Math.ceil(fgWidth / fgAspectRatio);
  } else {
    fgHeight = outputSize.height;
    fgWidth = Math.ceil(fgHeight * fgAspectRatio);
  }

  const resizedFg = await foreground
    .resize({ width: fgWidth, height: fgHeight, fit: 'inside' })
    .toBuffer();

  const fgLeft = Math.round((outputSize.width - fgWidth) * (fgAlignX / 100));
  const fgTop = Math.round((outputSize.height - fgHeight) * (fgAlignY / 100));

  return sharp(croppedBg)
    .composite([{ input: resizedFg, left: fgLeft, top: fgTop }])
    .toBuffer();
}

async function generateIco(foreground, background, outputIco, icoSizes, fgAdjust, bgAdjust) {
  console.log("Processing favicon with ICO sizes:", icoSizes);

  const tempPngPaths = [];
  const icoSizesBuffers = [];

  // Convert new array format [16, 32, 48, ...] into { width, height } objects
  const formattedIcoSizes = icoSizes.map(size => ({ width: size, height: size }));

  for (const size of formattedIcoSizes) {
    if (!size || !size.width || !size.height) {
      console.error("Invalid ICO size entry:", size);
      continue; // Skip invalid size entries
    }

    const tempPath = path.join(path.dirname(outputIco), `_temp_favicon_${size.width}x${size.height}.png`);
    try {
      // Use createFinalImage to apply blur, modulate, and proper scaling
      const outputBuffer = await createFinalImage(
        foreground,
        background ? background : null,
        { width: size.width, height: size.height },
        fgAdjust,
        bgAdjust
      );

      await sharp(outputBuffer).toFile(tempPath);
      tempPngPaths.push(tempPath);
      icoSizesBuffers.push(fs.readFileSync(tempPath));
    } catch (err) {
      console.error(`Failed to create PNG for size ${size.width}x${size.height}:`, err);
    }
  }

  if (icoSizesBuffers.length === 0) {
    throw new Error(`No valid ICO sizes provided, unable to generate ${outputIco}`);
  }

  try {
    const icoBuffer = await pngToIco(icoSizesBuffers);
    fs.writeFileSync(outputIco, icoBuffer);
    console.log(`Saved ${outputIco}`);
  } catch (err) {
    console.error(`Failed to create ${outputIco}:`, err);
  } finally {
    // Clean up temporary PNG files
    tempPngPaths.forEach((filePath) => {
      try {
        fs.unlinkSync(filePath);
      } catch (err) {
        console.warn("Failed to delete temporary file:", filePath, err);
      }
    });
  }
}

async function createFinalImage(fgImg, bgImg, outputSize, fgAdjust, bgAdjust) {
  let finalBgImage = bgImg ? bgImg.clone() : null;
  let finalFgImage = fgImg.clone();

  // Define a base reference size for consistent blur scaling
  const BASE_SIZE = 256; // The resolution where blur appears "as intended"
  
  // Calculate blur scaling factor based on output size
  const scaleFactor = Math.sqrt((outputSize.width * outputSize.height) / (BASE_SIZE * BASE_SIZE));

  // Apply background effects (blur, modulate) if a background exists
  if (finalBgImage) {
    if (bgAdjust.blur > 0) {
      const scaledBlur = bgAdjust.blur * scaleFactor;
      finalBgImage = finalBgImage.blur(scaledBlur);
    }
    if (Object.keys(bgAdjust.modulate).length) finalBgImage = finalBgImage.modulate(bgAdjust.modulate);
  }

  // Apply foreground effects (blur, modulate)
  if (fgAdjust.blur > 0) {
    const scaledBlur = fgAdjust.blur * scaleFactor;
    finalFgImage = finalFgImage.blur(scaledBlur);
  }
  if (Object.keys(fgAdjust.modulate).length) {
    const fgBuffer = await finalFgImage.modulate(fgAdjust.modulate).toBuffer();
    finalFgImage = sharp(fgBuffer);
  }

  // // Pass directly to createCompositeImage (which now handles alignment & resizing)
  // return createCompositeImage(finalFgImage, finalBgImage, outputSize, fgAdjust.alignment, bgAdjust.alignment);
  
  if (finalBgImage) {
    return createCompositeImage(finalFgImage, finalBgImage, outputSize, fgAdjust.alignment, bgAdjust.alignment);
  } else {
    // If no background, return just the foreground resized to fit outputSize
    return finalFgImage.resize(outputSize).toBuffer();
  }
}

async function processFavicon(options) {
  const {
    inputForeground,
    inputForegroundWide,
    inputBackground,
    outputImage,
    outputIco,
    setting
  } = options;

  // Extract settings from config
  const icoSizes = setting.size?.ico || [];
  const imageSizes = setting.size?.image || {};
  const fgAdjust = setting.adjust?.foreground || {};
  const bgAdjust = setting.adjust?.background || {};

  // Ensure output directories exist
  fs.mkdirSync(outputImage, { recursive: true });
  fs.mkdirSync(path.dirname(outputIco), { recursive: true });

  // Load images
  const mainImage = sharp(inputForeground);
  const wideImage = inputForegroundWide && fs.existsSync(inputForegroundWide) ? sharp(inputForegroundWide) : mainImage;
  const backgroundImage = inputBackground && fs.existsSync(inputBackground) ? sharp(inputBackground) : mainImage;

  // sharp({
  //   create: {
  //     width: outputSize.width,
  //     height: outputSize.height,
  //     channels: 4,
  //     background: { r: 0, g: 0, b: 0, alpha: 0 }
  //   }
  // })

  // Generate image files
  for (const [name, size] of Object.entries(imageSizes)) {
    const outputPath = path.join(outputImage, name);

    const fgImg = size.width > size.height ? wideImage : mainImage;
    const useBG = size.width > size.height ? bgAdjust.apply?.wide : bgAdjust.apply?.square;
    const outputBuffer = await createFinalImage(fgImg, useBG ? backgroundImage : null, size, fgAdjust, bgAdjust);

    await sharp(outputBuffer).toFile(outputPath);
    console.log(`Saved ${outputPath}`);
  }

  // Generate favicon.ico
  await generateIco(mainImage, bgAdjust.apply?.square ? backgroundImage : null, outputIco, icoSizes, fgAdjust, bgAdjust);
}

// Export the function
module.exports = processFavicon;
