var through = require("through2"),
	gutil = require("gulp-util"),
	gm = require('gm');

// FIXME Issue: "Add static GraphicsMagick for Linux #81"
// process.env.LD_LIBRARY_PATH = "./source/tool/graphicsmagick/linux/lib:" + process.env.LD_LIBRARY_PATH;

// FIXME Issue: "Add static GraphicsMagick for Linux #81"
// const gm = require('gm').subClass({
// 	appPath: './source/tool/graphicsmagick/linux/bin/'
// });

const { exec } = require("child_process");

exec(`${gm()._options.appPath || 'gm'} -version`, (error, stdout, stderr) => {
  if (error) {
    console.error(`‚ùå GraphicsMagick not found or misconfigured: ${error.message}`);
    console.error(`üí° STDERR: ${stderr}`);
  } else {
    console.info(`‚úÖ GraphicsMagick version:\n${stdout}`);
  }
});

module.exports = function (param) {
	"use strict";

	// if necessary check for required param(s), e.g. options hash, etc.
	if (!param) {
		throw new gutil.PluginError("gulp-watermark", "No param supplied");
	}

	// see "Writing a plugin"
	// https://github.com/gulpjs/gulp/blob/master/docs/writing-a-plugin/README.md
	function watermark(file, enc, callback) {
		/*jshint validthis:true*/

		// Do nothing if no contents
		if (file.isNull()) {
			this.push(file);
			return callback();
		}

		if (file.isStream()) {

			// http://nodejs.org/api/stream.html
			// http://nodejs.org/api/child_process.html
			// https://github.com/dominictarr/event-stream

			// accepting streams is optional
			this.emit("error",
				new gutil.PluginError("gulp-watermark", "Stream content is not supported"));
			return callback();
		}

		// check if file.contents is a `Buffer`
		if (file.isBuffer()) {

			/**
			 * -gravity
			 *   NorthWest,
			 *   North,
			 *   NorthEast,
			 *   West,
			 *   Center,
			 *   East,
			 *   SouthWest,
			 *   South,
			 *   SouthEast
			 *
			 * -resize
			 *   Ex. 50%
			 *
			 * -dissolve
			 *   Ex. 50
			 */
			var gravity = param.gravity || 'SouthEast';
			var resize = param.resize || '100%';
			var dissolve = param.dissolve || '100';
			var background = param.background || 'none';
			var gmOptions = param.gmOptions || '';
			// var imageMagick = param.imageMagick !== undefined ? param.imageMagick : true;
      //
			// gm = gm.subClass({
			// 	imageMagick: imageMagick
			// });

      let gmPipeline = gm(file.contents, file.path)
        .command("composite")
        .in("-gravity", gravity)
        .in("-resize", resize)
        .in("-dissolve", dissolve)
        .in("-background", background);
				// .in("-debug", "All");

			if (gmOptions && typeof gmOptions === "string" && gmOptions.trim() !== "") {
				gmPipeline = gmPipeline.in(gmOptions);
			}

      // gmPipeline.in(param.image).toBuffer((err, buffer) => {
      //   if (err) {
      //     return callback(
      //       new gutil.PluginError("gulp-watermark", "GraphicsMagick Error: " + err.message)
      //     );
      //   }
      //   file.contents = buffer;
      //   this.push(file);
      //   callback();
      // });

			try {
				const gmProcess = gmPipeline.in(param.image).stream((err, stdout, stderr) => {
					if (err) {
						console.error(`‚ùå GraphicsMagick Error (Stream Init): ${err.message}`);
						return callback(new gutil.PluginError("gulp-watermark", err.message));
					}

					let chunks = [];
					let stderrChunks = [];

					stdout.on("data", (chunk) => chunks.push(chunk));
					stdout.on("end", () => {
						file.contents = Buffer.concat(chunks);
						this.push(file);
						console.info(`‚úÖ üìÇ File processed: ${file.path}`);
						callback();
					});

					stderr.on("data", (data) => {
						const message = data.toString();
						stderrChunks.push(message);
						console.warn(`‚ö†Ô∏è GraphicsMagick STDERR chunk: ${message}`);
					});

					stderr.on("end", () => {
						const fullStderr = stderrChunks.join('');
						if (fullStderr.length > 0) {
							console.error(`‚ùå üìú Full STDERR output:\n${fullStderr}`);
							if (fullStderr.includes('not found') || fullStderr.includes('ENOENT')) {
								console.error(`üí° Suggestion: Check if GraphicsMagick is installed and the path is correct: ${gm()._options.appPath}`);
							}
							return callback(new gutil.PluginError("gulp-watermark", `GraphicsMagick error: ${fullStderr}`));
						} 
						// else {
						// 	console.info(`üìú STDERR stream ended with no output. If issues persist, verify GraphicsMagick installation.`);
						// }
					});

					stdout.on("error", (streamErr) => {
						console.error(`‚ùå üö® Error in STDOUT stream: ${streamErr.message}`);
						callback(new gutil.PluginError("gulp-watermark", streamErr.message));
					});

					stderr.on("error", (stderrErr) => {
						console.error(`‚ùå üö® Error in STDERR stream: ${stderrErr.message}`);
						callback(new gutil.PluginError("gulp-watermark", stderrErr.message));
					});
				});

				gmProcess.on('close', (code) => {
					if (code !== 0) {
						const errorMsg = `‚ùå GraphicsMagick process exited with code ${code}. Check STDERR logs above.`;
						console.error(errorMsg);
						callback(new gutil.PluginError("gulp-watermark", errorMsg)); // Propagate error properly
					} else {
						console.info(`‚úÖ GraphicsMagick process exited successfully with code ${code}.`);
					}
				});
			} catch (syncErr) {
				console.error(`‚ùå Synchronous GraphicsMagick error: ${syncErr.message}`);
				return callback(new gutil.PluginError("gulp-watermark", syncErr.message));
			}
		} else {
			// accepting streams is optional
			this.emit(
				"error",
				new gutil.PluginError("gulp-watermark", "Undefined file error")
			);
			return callback();
		}

	}

	return through.obj(watermark);
};
